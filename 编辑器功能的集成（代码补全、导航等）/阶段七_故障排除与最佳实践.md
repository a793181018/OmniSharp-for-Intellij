# 阶段七：故障排除与最佳实践

## 1. 故障排除概述

OmniSharp-for-Intellij 插件在使用过程中可能会遇到各种问题，如服务连接失败、功能异常或性能问题。本阶段将详细介绍常见问题的排查方法、日志系统的使用以及调试技巧，帮助开发者快速诊断和解决问题。

### 1.1 故障排除流程

高效的故障排除流程通常包括以下步骤：

1. **问题识别**：明确问题的具体表现和复现步骤
2. **日志收集**：检查 OmniSharp 服务器和插件日志
3. **诊断分析**：分析日志和错误信息
4. **解决方案实施**：应用适当的修复措施
5. **验证解决**：确认问题是否已解决
6. **问题记录**：记录问题和解决方案以供将来参考

## 2. 常见问题排查

### 2.1 OmniSharp 服务器连接问题

```kotlin
// OmniSharp 连接状态检查工具
class OmniSharpConnectionDiagnostics(project: Project) {
    private val project = project
    private val communicator = project.getService(OmniSharpCommunicator::class.java)
    
    /**
     * 执行连接诊断
     */
    fun runDiagnostics(): ConnectionDiagnosticsResult {
        val result = ConnectionDiagnosticsResult()
        
        // 检查服务器是否运行
        checkServerRunning(result)
        
        // 检查连接状态
        checkConnectionStatus(result)
        
        // 测试基本请求
        testBasicRequest(result)
        
        return result
    }
    
    /**
     * 检查服务器是否运行
     */
    private fun checkServerRunning(result: ConnectionDiagnosticsResult) {
        val serverProcess = communicator.getServerProcess()
        if (serverProcess == null || !serverProcess.isAlive) {
            result.addIssue(
                "ServerNotRunning",
                "OmniSharp server process is not running",
                "Restart the OmniSharp server from the plugin settings or restart IntelliJ IDEA"
            )
        } else {
            result.serverProcessStatus = "Running"
        }
    }
    
    /**
     * 检查连接状态
     */
    private fun checkConnectionStatus(result: ConnectionDiagnosticsResult) {
        val connectionStatus = communicator.getConnectionStatus()
        if (connectionStatus != ConnectionStatus.CONNECTED) {
            result.addIssue(
                "ConnectionFailed",
                "Failed to connect to OmniSharp server: $connectionStatus",
                "Check if the server is running and the port is correct"
            )
        } else {
            result.connectionStatus = "Connected"
        }
    }
    
    /**
     * 测试基本请求
     */
    private fun testBasicRequest(result: ConnectionDiagnosticsResult) {
        try {
            val response = communicator.sendRequest("{\"Command\":\"project\",\"FileName\":\"$project.basePath\"}")
            if (response != null) {
                result.testRequestStatus = "Success"
                result.serverVersion = extractServerVersion(response)
            } else {
                result.addIssue(
                    "RequestFailed",
                    "Basic request to server failed",
                    "Check server logs for more details"
                )
            }
        } catch (e: Exception) {
            result.addIssue(
                "RequestError",
                "Error sending request to server: ${e.message}",
                "Check server logs and network settings"
            )
        }
    }
    
    /**
     * 提取服务器版本
     */
    private fun extractServerVersion(response: String): String {
        try {
            val jsonNode = ObjectMapper().readTree(response)
            return jsonNode.get("Version").asText()
        } catch (e: Exception) {
            return "Unknown"
        }
    }
}

// 连接诊断结果类
class ConnectionDiagnosticsResult {
    var serverProcessStatus: String = "Unknown"
    var connectionStatus: String = "Unknown"
    var testRequestStatus: String = "Unknown"
    var serverVersion: String = "Unknown"
    private val issues = mutableListOf<DiagnosticIssue>()
    
    fun addIssue(code: String, message: String, solution: String) {
        issues.add(DiagnosticIssue(code, message, solution))
    }
    
    fun getIssues(): List<DiagnosticIssue> {
        return issues
    }
    
    fun hasIssues(): Boolean {
        return issues.isNotEmpty()
    }
    
    override fun toString(): String {
        val sb = StringBuilder()
        sb.append("Connection Diagnostics Result:\n")
        sb.append("- Server Process: $serverProcessStatus\n")
        sb.append("- Connection Status: $connectionStatus\n")
        sb.append("- Test Request: $testRequestStatus\n")
        sb.append("- Server Version: $serverVersion\n")
        
        if (hasIssues()) {
            sb.append("\nIssues found:\n")
            issues.forEachIndexed { index, issue ->
                sb.append("${index + 1}. [${issue.code}] ${issue.message}\n")
                sb.append("   Solution: ${issue.solution}\n")
            }
        }
        
        return sb.toString()
    }
}

// 诊断问题类
data class DiagnosticIssue(val code: String, val message: String, val solution: String)
```

### 2.2 代码补全问题排查

```kotlin
// 代码补全诊断工具
class OmniSharpCompletionDiagnostics(project: Project) {
    private val project = project
    private val completionService = project.getService(OmniSharpCompletionService::class.java)
    private val cacheManager = project.getService(OmniSharpCacheManager::class.java)
    
    /**
     * 诊断代码补全问题
     */
    fun diagnoseCompletionIssue(editor: Editor, file: VirtualFile): CompletionDiagnosticsResult {
        val result = CompletionDiagnosticsResult()
        
        // 检查文件类型
        checkFileType(file, result)
        
        // 检查缓存状态
        checkCacheStatus(file, result)
        
        // 测试代码补全
        testCompletion(editor, file, result)
        
        return result
    }
    
    /**
     * 检查文件类型
     */
    private fun checkFileType(file: VirtualFile, result: CompletionDiagnosticsResult) {
        if (file.extension != "cs") {
            result.addIssue(
                "InvalidFileType",
                "Code completion is only supported for C# files",
                "Make sure you are editing a .cs file"
            )
        }
    }
    
    /**
     * 检查缓存状态
     */
    private fun checkCacheStatus(file: VirtualFile, result: CompletionDiagnosticsResult) {
        val cacheKey = "completion_${file.path}"
        if (cacheManager.get(cacheKey, CompletionResult::class.java) == null) {
            result.addInfo("No cached completion results found")
        } else {
            result.addInfo("Completion results found in cache")
        }
    }
    
    /**
     * 测试代码补全
     */
    private fun testCompletion(editor: Editor, file: VirtualFile, result: CompletionDiagnosticsResult) {
        try {
            val caretModel = editor.caretModel
            val caretOffset = caretModel.offset
            
            // 记录执行时间
            val startTime = System.currentTimeMillis()
            val completions = completionService.getCompletions(file, caretOffset).block()
            val executionTime = System.currentTimeMillis() - startTime
            
            result.executionTime = executionTime
            
            if (completions != null) {
                result.completionCount = completions.items.size
                
                if (completions.items.isEmpty()) {
                    result.addIssue(
                        "NoCompletions",
                        "No completions were returned for the current position",
                        "Try moving the caret to a different position or check if the file is properly analyzed"
                    )
                } else {
                    result.addInfo("Successfully retrieved ${completions.items.size} completions in ${executionTime}ms")
                    
                    // 记录前几个补全项作为样本
                    completions.items.take(5).forEach { item ->
                        result.addInfo("- ${item.displayText} (${item.kind})")
                    }
                }
            } else {
                result.addIssue(
                    "CompletionFailed",
                    "Failed to retrieve completions",
                    "Check OmniSharp server logs for more details"
                )
            }
        } catch (e: Exception) {
            result.addIssue(
                "CompletionError",
                "Error during completion: ${e.message}",
                "Check plugin logs and OmniSharp server logs"
            )
        }
    }
}

// 代码补全诊断结果类
class CompletionDiagnosticsResult {
    var executionTime: Long = -1
    var completionCount: Int = 0
    private val issues = mutableListOf<DiagnosticIssue>()
    private val infoMessages = mutableListOf<String>()
    
    fun addIssue(code: String, message: String, solution: String) {
        issues.add(DiagnosticIssue(code, message, solution))
    }
    
    fun addInfo(message: String) {
        infoMessages.add(message)
    }
    
    fun getIssues(): List<DiagnosticIssue> {
        return issues
    }
    
    fun getInfoMessages(): List<String> {
        return infoMessages
    }
    
    fun hasIssues(): Boolean {
        return issues.isNotEmpty()
    }
}
```

### 2.3 性能问题排查

```kotlin
// 性能问题诊断工具
class OmniSharpPerformanceDiagnostics(project: Project) {
    private val project = project
    private val performanceMonitor = project.getService(OmniSharpPerformanceMonitor::class.java)
    private val cacheManager = project.getService(OmniSharpCacheManager::class.java)
    
    /**
     * 诊断性能问题
     */
    fun diagnosePerformanceIssues(): PerformanceDiagnosticsResult {
        val result = PerformanceDiagnosticsResult()
        
        // 检查任务执行时间
        checkTaskExecutionTimes(result)
        
        // 检查缓存使用情况
        checkCacheUsage(result)
        
        // 检查活动任务
        checkActiveTasks(result)
        
        return result
    }
    
    /**
     * 检查任务执行时间
     */
    private fun checkTaskExecutionTimes(result: PerformanceDiagnosticsResult) {
        val metrics = performanceMonitor.getPerformanceMetrics()
        
        metrics.forEach { (taskName, metric) ->
            if (metric.averageDuration > 1000) { // 1秒
                result.addIssue(
                    "SlowTask",
                    "Task '$taskName' is taking too long: ${metric.averageDuration}ms average",
                    "Check if the task can be optimized or cached"
                )
            }
            
            if (metric.count > 1000) {
                result.addIssue(
                    "FrequentTask",
                    "Task '$taskName' is executed too frequently: ${metric.count} times",
                    "Consider debouncing or throttling the task"
                )
            }
        }
    }
    
    /**
     * 检查缓存使用情况
     */
    private fun checkCacheUsage(result: PerformanceDiagnosticsResult) {
        // 这里可以添加缓存使用情况检查
        // 例如：检查缓存大小、命中率等
        result.addInfo("Cache diagnostics not fully implemented yet")
    }
    
    /**
     * 检查活动任务
     */
    private fun checkActiveTasks(result: PerformanceDiagnosticsResult) {
        // 这里可以添加活动任务检查
        result.addInfo("Active tasks diagnostics not fully implemented yet")
    }
}

// 性能诊断结果类
class PerformanceDiagnosticsResult {
    private val issues = mutableListOf<DiagnosticIssue>()
    private val infoMessages = mutableListOf<String>()
    
    fun addIssue(code: String, message: String, solution: String) {
        issues.add(DiagnosticIssue(code, message, solution))
    }
    
    fun addInfo(message: String) {
        infoMessages.add(message)
    }
    
    fun getIssues(): List<DiagnosticIssue> {
        return issues
    }
    
    fun getInfoMessages(): List<String> {
        return infoMessages
    }
    
    fun hasIssues(): Boolean {
        return issues.isNotEmpty()
    }
}
```

## 3. 日志系统

### 3.1 日志配置

```kotlin
// 日志配置类
class OmniSharpLogConfiguration {
    companion object {
        /**
         * 配置日志系统
         */
        fun configure(project: Project) {
            // 配置插件日志
            configurePluginLogger()
            
            // 配置 OmniSharp 服务器日志
            configureServerLogger(project)
        }
        
        /**
         * 配置插件日志
         */
        private fun configurePluginLogger() {
            val logger = Logger.getInstance("OmniSharp")
            
            // 设置日志级别
            setLogLevel(logger, getLogLevelSetting())
            
            // 配置日志文件
            configurePluginLogFile()
        }
        
        /**
         * 配置 OmniSharp 服务器日志
         */
        private fun configureServerLogger(project: Project) {
            val serverLogLevel = getServerLogLevelSetting()
            val serverLogPath = getServerLogPath(project)
            
            // 创建日志目录
            File(serverLogPath).parentFile.mkdirs()
            
            // 更新服务器启动参数
            val settings = OmniSharpSettings.getInstance(project)
            settings.serverArguments = "--loglevel $serverLogLevel --logfile $serverLogPath"
        }
        
        /**
         * 获取日志级别设置
         */
        private fun getLogLevelSetting(): LogLevel {
            val levelName = PropertiesComponent.getInstance().getValue("omnisharp.log.level", "INFO")
            return when (levelName.uppercase()) {
                "DEBUG" -> LogLevel.DEBUG
                "TRACE" -> LogLevel.TRACE
                "WARN" -> LogLevel.WARN
                "ERROR" -> LogLevel.ERROR
                else -> LogLevel.INFO
            }
        }
        
        /**
         * 获取服务器日志级别设置
         */
        private fun getServerLogLevelSetting(): String {
            return PropertiesComponent.getInstance().getValue("omnisharp.server.log.level", "Information")
        }
        
        /**
         * 获取服务器日志路径
         */
        private fun getServerLogPath(project: Project): String {
            return project.basePath + "/.omnisharp/logs/server.log"
        }
        
        /**
         * 设置日志级别
         */
        private fun setLogLevel(logger: Logger, level: LogLevel) {
            (logger as? IdeaLoggingEventLogger)?.apply {
                // 设置日志级别
            }
        }
        
        /**
         * 配置插件日志文件
         */
        private fun configurePluginLogFile() {
            val logPath = getPluginLogPath()
            
            // 创建日志目录
            File(logPath).parentFile.mkdirs()
            
            // 配置文件处理器
            // 注意：具体实现可能依赖于 IntelliJ 平台的日志系统
        }
        
        /**
         * 获取插件日志路径
         */
        private fun getPluginLogPath(): String {
            val systemPath = System.getProperty("user.home")
            return "$systemPath/.omnisharp/logs/plugin.log"
        }
    }
}
```

### 3.2 日志查看器

```kotlin
// 日志查看器工厂
class OmniSharpLogViewerFactory : ToolWindowFactory {
    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        val logViewer = OmniSharpLogViewer(project)
        toolWindow.contentManager.addContent(logViewer)
    }
    
    override fun shouldBeAvailable(project: Project): Boolean {
        return true
    }
}

// 日志查看器内容
class OmniSharpLogViewer(project: Project) : ToolWindowContent(project) {
    private val project = project
    private val contentPanel = JPanel(BorderLayout())
    private val logTextArea = JTextArea()
    private val tabbedPane = JTabbedPane()
    private val pluginLogTab = createLogTab("Plugin Log", getPluginLogPath())
    private val serverLogTab = createLogTab("Server Log", getServerLogPath())
    private val logLevelComboBox = JComboBox(arrayOf("ALL", "TRACE", "DEBUG", "INFO", "WARN", "ERROR"))
    private val refreshButton = JButton("Refresh")
    private val clearButton = JButton("Clear")
    private val autoRefreshCheckBox = JCheckBox("Auto Refresh")
    private var autoRefreshTimer: ScheduledFuture<*>? = null
    
    init {
        initUI()
        component = contentPanel
        
        // 初始加载日志
        loadSelectedLog()
        
        // 设置自动刷新
        setupAutoRefresh()
    }
    
    /**
     * 初始化 UI
     */
    private fun initUI() {
        // 添加标签页
        tabbedPane.addTab("Plugin Log", pluginLogTab)
        tabbedPane.addTab("Server Log", serverLogTab)
        tabbedPane.addChangeListener { loadSelectedLog() }
        
        // 创建工具栏
        val toolbar = JToolBar()
        toolbar.add(logLevelComboBox)
        toolbar.addSeparator()
        toolbar.add(refreshButton)
        toolbar.add(clearButton)
        toolbar.add(autoRefreshCheckBox)
        
        // 设置按钮事件
        refreshButton.addActionListener { loadSelectedLog() }
        clearButton.addActionListener { clearCurrentLog() }
        autoRefreshCheckBox.addActionListener { setupAutoRefresh() }
        
        // 设置内容
        contentPanel.add(toolbar, BorderLayout.NORTH)
        contentPanel.add(tabbedPane, BorderLayout.CENTER)
    }
    
    /**
     * 创建日志标签页
     */
    private fun createLogTab(title: String, logFilePath: String): JComponent {
        val panel = JPanel(BorderLayout())
        val textArea = JTextArea()
        textArea.isEditable = false
        textArea.lineWrap = true
        textArea.wrapStyleWord = true
        textArea.font = Font("Monospaced", Font.PLAIN, 12)
        
        panel.add(JScrollPane(textArea), BorderLayout.CENTER)
        return panel
    }
    
    /**
     * 加载选中的日志
     */
    private fun loadSelectedLog() {
        val selectedIndex = tabbedPane.selectedIndex
        val logFilePath = if (selectedIndex == 0) getPluginLogPath() else getServerLogPath()
        val textArea = (tabbedPane.selectedComponent as JPanel).getComponent(0) as JScrollPane
            .viewport.view as JTextArea
        
        loadLogFile(logFilePath, textArea)
    }
    
    /**
     * 加载日志文件
     */
    private fun loadLogFile(filePath: String, textArea: JTextArea) {
        try {
            val logFile = File(filePath)
            if (logFile.exists()) {
                val logContent = FileUtils.readFileToString(logFile, StandardCharsets.UTF_8)
                val filteredContent = filterLogByLevel(logContent)
                textArea.text = filteredContent
                textArea.caretPosition = textArea.document.length // 滚动到底部
            } else {
                textArea.text = "Log file not found: $filePath"
            }
        } catch (e: Exception) {
            textArea.text = "Error loading log file: ${e.message}"
        }
    }
    
    /**
     * 根据日志级别过滤日志
     */
    private fun filterLogByLevel(logContent: String): String {
        val selectedLevel = logLevelComboBox.selectedItem.toString()
        if (selectedLevel == "ALL") {
            return logContent
        }
        
        val filteredLines = logContent.lines().filter { line ->
            when (selectedLevel) {
                "TRACE" -> line.contains("TRACE") || line.contains("DEBUG") || line.contains("INFO") || 
                         line.contains("WARN") || line.contains("ERROR")
                "DEBUG" -> line.contains("DEBUG") || line.contains("INFO") || line.contains("WARN") || 
                         line.contains("ERROR")
                "INFO" -> line.contains("INFO") || line.contains("WARN") || line.contains("ERROR")
                "WARN" -> line.contains("WARN") || line.contains("ERROR")
                "ERROR" -> line.contains("ERROR")
                else -> true
            }
        }
        
        return filteredLines.joinToString("\n")
    }
    
    /**
     * 清除当前日志
     */
    private fun clearCurrentLog() {
        val textArea = (tabbedPane.selectedComponent as JPanel).getComponent(0) as JScrollPane
            .viewport.view as JTextArea
        textArea.text = ""
    }
    
    /**
     * 设置自动刷新
     */
    private fun setupAutoRefresh() {
        // 取消之前的定时器
        autoRefreshTimer?.cancel(false)
        autoRefreshTimer = null
        
        if (autoRefreshCheckBox.isSelected) {
            autoRefreshTimer = Executors.newScheduledThreadPool(1).scheduleAtFixedRate({
                SwingUtilities.invokeLater {
                    loadSelectedLog()
                }
            }, 5, 5, TimeUnit.SECONDS)
        }
    }
    
    /**
     * 获取插件日志路径
     */
    private fun getPluginLogPath(): String {
        val systemPath = System.getProperty("user.home")
        return "$systemPath/.omnisharp/logs/plugin.log"
    }
    
    /**
     * 获取服务器日志路径
     */
    private fun getServerLogPath(): String {
        return project.basePath + "/.omnisharp/logs/server.log"
    }
    
    override fun dispose() {
        // 取消自动刷新定时器
        autoRefreshTimer?.cancel(false)
    }
}
```

## 4. 调试技巧

### 4.1 远程调试 OmniSharp 服务器

```kotlin
// 远程调试管理器
class OmniSharpRemoteDebugManager(project: Project) {
    private val project = project
    private var isDebugModeEnabled = false
    private val DEBUG_PORT = 4000
    
    /**
     * 启用远程调试
     */
    fun enableRemoteDebugging(): Boolean {
        if (isDebugModeEnabled) {
            return true
        }
        
        try {
            // 停止当前服务器
            val serverManager = project.getService(OmniSharpServerManager::class.java)
            serverManager.stopServer()
            
            // 添加调试参数
            val settings = OmniSharpSettings.getInstance(project)
            settings.serverArguments = "${settings.serverArguments} --debug --debug-port $DEBUG_PORT"
            
            // 重启服务器
            serverManager.startServer()
            
            isDebugModeEnabled = true
            return true
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").error("Failed to enable remote debugging", e)
            return false
        }
    }
    
    /**
     * 禁用远程调试
     */
    fun disableRemoteDebugging(): Boolean {
        if (!isDebugModeEnabled) {
            return true
        }
        
        try {
            // 停止当前服务器
            val serverManager = project.getService(OmniSharpServerManager::class.java)
            serverManager.stopServer()
            
            // 移除调试参数
            val settings = OmniSharpSettings.getInstance(project)
            settings.serverArguments = settings.serverArguments
                .replace(" --debug", "")
                .replace(" --debug-port $DEBUG_PORT", "")
            
            // 重启服务器
            serverManager.startServer()
            
            isDebugModeEnabled = false
            return true
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").error("Failed to disable remote debugging", e)
            return false
        }
    }
    
    /**
     * 检查调试模式是否启用
     */
    fun isDebuggingEnabled(): Boolean {
        return isDebugModeEnabled
    }
    
    /**
     * 获取调试端口
     */
    fun getDebugPort(): Int {
        return DEBUG_PORT
    }
}
```

### 4.2 断点与性能分析

```kotlin
// 断点管理器
class OmniSharpBreakpointManager(project: Project) {
    private val project = project
    private val breakpoints = mutableListOf<OmniSharpBreakpoint>()
    private val breakpointListener = object : BreakpointListener {
        override fun breakpointAdded(breakpoint: Breakpoint) {
            // 处理断点添加
            if (breakpoint is LineBreakpoint<*> && isCSharpFile(breakpoint.sourcePosition?.file)) {
                addBreakpoint(breakpoint)
            }
        }
        
        override fun breakpointRemoved(breakpoint: Breakpoint) {
            // 处理断点移除
            if (breakpoint is LineBreakpoint<*> && isCSharpFile(breakpoint.sourcePosition?.file)) {
                removeBreakpoint(breakpoint)
            }
        }
    }
    
    init {
        // 注册断点监听器
        registerBreakpointListener()
    }
    
    /**
     * 注册断点监听器
     */
    private fun registerBreakpointListener() {
        BreakpointManager.getInstance(project).addBreakpointListener(breakpointListener)
    }
    
    /**
     * 添加断点
     */
    private fun addBreakpoint(breakpoint: LineBreakpoint<*>) {
        val file = breakpoint.sourcePosition?.file
        val line = breakpoint.sourcePosition?.line
        
        if (file != null && line != null) {
            val omniSharpBreakpoint = OmniSharpBreakpoint(file.path, line)
            breakpoints.add(omniSharpBreakpoint)
            
            // 通知 OmniSharp 服务器添加断点
            notifyServerOfBreakpointChange("add", omniSharpBreakpoint)
        }
    }
    
    /**
     * 移除断点
     */
    private fun removeBreakpoint(breakpoint: LineBreakpoint<*>) {
        val file = breakpoint.sourcePosition?.file
        val line = breakpoint.sourcePosition?.line
        
        if (file != null && line != null) {
            val omniSharpBreakpoint = OmniSharpBreakpoint(file.path, line)
            breakpoints.remove(omniSharpBreakpoint)
            
            // 通知 OmniSharp 服务器移除断点
            notifyServerOfBreakpointChange("remove", omniSharpBreakpoint)
        }
    }
    
    /**
     * 通知服务器断点变更
     */
    private fun notifyServerOfBreakpointChange(action: String, breakpoint: OmniSharpBreakpoint) {
        val request = BreakpointChangeRequest(action, breakpoint)
        val communicator = project.getService(OmniSharpCommunicator::class.java)
        
        communicator.sendRequest(request)
            .doOnError { e ->
                Logger.getInstance("OmniSharp").error("Failed to notify server of breakpoint change", e)
            }
            .subscribe()
    }
    
    /**
     * 检查是否是 C# 文件
     */
    private fun isCSharpFile(file: VirtualFile?): Boolean {
        return file?.extension == "cs"
    }
    
    /**
     * 获取所有断点
     */
    fun getAllBreakpoints(): List<OmniSharpBreakpoint> {
        return breakpoints.toList()
    }
    
    /**
     * 清除所有断点
     */
    fun clearAllBreakpoints() {
        breakpoints.forEach {
            notifyServerOfBreakpointChange("remove", it)
        }
        breakpoints.clear()
    }
}

// OmniSharp 断点类
data class OmniSharpBreakpoint(val filePath: String, val line: Int)

// 断点变更请求类
class BreakpointChangeRequest(val action: String, val breakpoint: OmniSharpBreakpoint)
```

## 5. 最佳实践

### 5.1 开发工作流

#### 5.1.1 增量开发

1. **模块化设计**：将功能分解为小而独立的模块，便于增量开发和测试
2. **单元测试**：为每个模块编写单元测试，确保功能正确性
3. **集成测试**：验证模块之间的交互是否正常
4. **持续集成**：使用 CI/CD 工具自动运行测试和构建

#### 5.1.2 版本控制

1. **分支策略**：使用 Git Flow 或 GitHub Flow 管理分支
2. **提交规范**：遵循提交消息规范，如 Conventional Commits
3. **代码审查**：在合并前进行代码审查，确保代码质量

### 5.2 项目组织结构

```kotlin
// 推荐的项目结构示例
/*
OmniSharp-for-Intellij/
├── src/
│   ├── main/kotlin/
│   │   └── com/omnisharp/intellij/
│   │       ├── actions/          # IDE 操作
│   │       ├── completion/       # 代码补全相关功能
│   │       ├── diagnostics/      # 代码诊断相关功能
│   │       ├── formatting/       # 代码格式化相关功能
│   │       ├── navigation/       # 代码导航相关功能
│   │       ├── protocol/         # OmniSharp 协议相关类
│   │       ├── settings/         # 插件设置
│   │       ├── ui/               # UI 组件
│   │       ├── utils/            # 工具类
│   │       ├── OmniSharpPlugin.kt   # 插件入口
│   │       └── OmniSharpProjectComponent.kt # 项目组件
│   └── test/                    # 测试代码
├── resources/                   # 资源文件
├── build.gradle.kts             # Gradle 构建配置
└── README.md                    # 项目说明文档
*/
```

### 5.3 团队协作

#### 5.3.1 代码风格

1. **Kotlin 编码规范**：遵循 Kotlin 官方编码规范
2. **命名约定**：使用有意义的命名，遵循驼峰命名法
3. **文档注释**：为公共 API 添加文档注释

#### 5.3.2 代码审查

1. **审查清单**：创建代码审查清单，确保所有方面都被覆盖
2. **性能考虑**：检查是否有性能瓶颈
3. **错误处理**：确保适当的错误处理和日志记录
4. **测试覆盖**：确保新代码有足够的测试覆盖

#### 5.3.3 发布流程

1. **版本号管理**：遵循语义化版本控制
2. **发布前检查**：在发布前运行所有测试和检查
3. **发布说明**：为每个版本编写详细的发布说明
4. **用户反馈**：收集和响应用户反馈

## 6. 配置与部署

### 6.1 插件配置

```kotlin
// 插件配置面板
class OmniSharpSettingsConfigurable(project: Project) : SearchableConfigurable {
    private val project = project
    private val settings = OmniSharpSettings.getInstance(project)
    private val panel = JPanel(BorderLayout())
    private val formPanel = JPanel(GridBagLayout())
    private val serverPathTextField = JTextField()
    private val serverArgumentsTextField = JTextField()
    private val logLevelComboBox = JComboBox(arrayOf("ERROR", "WARN", "INFO", "DEBUG", "TRACE"))
    private val enableAutoCompletionCheckBox = JCheckBox("Enable code completion")
    private val enableNavigationCheckBox = JCheckBox("Enable code navigation")
    private val enableDiagnosticsCheckBox = JCheckBox("Enable code diagnostics")
    private val enableFormattingCheckBox = JCheckBox("Enable code formatting")
    
    init {
        initUI()
        loadSettings()
    }
    
    /**
     * 初始化 UI
     */
    private fun initUI() {
        val gbc = GridBagConstraints()
        gbc.insets = Insets(5, 5, 5, 5)
        gbc.fill = GridBagConstraints.HORIZONTAL
        
        // Server Path
        gbc.gridx = 0
        gbc.gridy = 0
        gbc.weightx = 0.0
        formPanel.add(JLabel("OmniSharp Server Path:"), gbc)
        
        gbc.gridx = 1
        gbc.weightx = 1.0
        formPanel.add(serverPathTextField, gbc)
        
        val browseButton = JButton("Browse...")
        browseButton.addActionListener { browseForServerPath() }
        gbc.gridx = 2
        gbc.weightx = 0.0
        formPanel.add(browseButton, gbc)
        
        // Server Arguments
        gbc.gridx = 0
        gbc.gridy = 1
        formPanel.add(JLabel("Server Arguments:"), gbc)
        
        gbc.gridx = 1
        gbc.gridwidth = 2
        formPanel.add(serverArgumentsTextField, gbc)
        
        // Log Level
        gbc.gridx = 0
        gbc.gridy = 2
        gbc.gridwidth = 1
        formPanel.add(JLabel("Log Level:"), gbc)
        
        gbc.gridx = 1
        formPanel.add(logLevelComboBox, gbc)
        
        // Features
        gbc.gridx = 0
        gbc.gridy = 3
        formPanel.add(JLabel("Features:"), gbc)
        
        gbc.gridx = 1
        formPanel.add(enableAutoCompletionCheckBox, gbc)
        
        gbc.gridx = 1
        gbc.gridy = 4
        formPanel.add(enableNavigationCheckBox, gbc)
        
        gbc.gridx = 1
        gbc.gridy = 5
        formPanel.add(enableDiagnosticsCheckBox, gbc)
        
        gbc.gridx = 1
        gbc.gridy = 6
        formPanel.add(enableFormattingCheckBox, gbc)
        
        panel.add(JScrollPane(formPanel), BorderLayout.CENTER)
    }
    
    /**
     * 浏览服务器路径
     */
    private fun browseForServerPath() {
        val fileChooser = JFileChooser()
        fileChooser.fileSelectionMode = JFileChooser.FILES_ONLY
        
        val result = fileChooser.showOpenDialog(panel)
        if (result == JFileChooser.APPROVE_OPTION) {
            serverPathTextField.text = fileChooser.selectedFile.absolutePath
        }
    }
    
    /**
     * 加载设置
     */
    private fun loadSettings() {
        serverPathTextField.text = settings.serverPath
        serverArgumentsTextField.text = settings.serverArguments
        logLevelComboBox.selectedItem = settings.logLevel
        enableAutoCompletionCheckBox.isSelected = settings.enableAutoCompletion
        enableNavigationCheckBox.isSelected = settings.enableNavigation
        enableDiagnosticsCheckBox.isSelected = settings.enableDiagnostics
        enableFormattingCheckBox.isSelected = settings.enableFormatting
    }
    
    /**
     * 保存设置
     */
    private fun saveSettings() {
        settings.serverPath = serverPathTextField.text
        settings.serverArguments = serverArgumentsTextField.text
        settings.logLevel = logLevelComboBox.selectedItem.toString()
        settings.enableAutoCompletion = enableAutoCompletionCheckBox.isSelected
        settings.enableNavigation = enableNavigationCheckBox.isSelected
        settings.enableDiagnostics = enableDiagnosticsCheckBox.isSelected
        settings.enableFormatting = enableFormattingCheckBox.isSelected
        
        // 应用设置
        applySettings()
    }
    
    /**
     * 应用设置
     */
    private fun applySettings() {
        // 重新配置日志系统
        OmniSharpLogConfiguration.configure(project)
        
        // 重启服务器以应用服务器相关设置
        if (settings.serverPath.isNotEmpty() || settings.serverArguments.isNotEmpty()) {
            val serverManager = project.getService(OmniSharpServerManager::class.java)
            serverManager.restartServer()
        }
    }
    
    override fun getDisplayName(): String {
        return "OmniSharp"
    }
    
    override fun getPreferredFocusedComponent(): JComponent? {
        return serverPathTextField
    }
    
    override fun createComponent(): JComponent {
        return panel
    }
    
    override fun isModified(): Boolean {
        return serverPathTextField.text != settings.serverPath ||
               serverArgumentsTextField.text != settings.serverArguments ||
               logLevelComboBox.selectedItem != settings.logLevel ||
               enableAutoCompletionCheckBox.isSelected != settings.enableAutoCompletion ||
               enableNavigationCheckBox.isSelected != settings.enableNavigation ||
               enableDiagnosticsCheckBox.isSelected != settings.enableDiagnostics ||
               enableFormattingCheckBox.isSelected != settings.enableFormatting
    }
    
    override fun apply() {
        saveSettings()
    }
    
    override fun reset() {
        loadSettings()
    }
    
    override fun getId(): String {
        return "OmniSharpSettings"
    }
    
    override fun getHelpTopic(): String? {
        return null
    }
}

// 插件设置类
class OmniSharpSettings(project: Project) : SimplePersistentStateComponent<OmniSharpSettings.State>(State()) {
    companion object {
        fun getInstance(project: Project): OmniSharpSettings {
            return project.service<OmniSharpSettings>()
        }
    }
    
    // 设置属性
    var serverPath: String
        get() = state.serverPath
        set(value) { state.serverPath = value }
    
    var serverArguments: String
        get() = state.serverArguments
        set(value) { state.serverArguments = value }
    
    var logLevel: String
        get() = state.logLevel
        set(value) { state.logLevel = value }
    
    var enableAutoCompletion: Boolean
        get() = state.enableAutoCompletion
        set(value) { state.enableAutoCompletion = value }
    
    var enableNavigation: Boolean
        get() = state.enableNavigation
        set(value) { state.enableNavigation = value }
    
    var enableDiagnostics: Boolean
        get() = state.enableDiagnostics
        set(value) { state.enableDiagnostics = value }
    
    var enableFormatting: Boolean
        get() = state.enableFormatting
        set(value) { state.enableFormatting = value }
    
    // 状态类
    class State : BaseState() {
        var serverPath by string("")
        var serverArguments by string("--loglevel Information")
        var logLevel by string("INFO")
        var enableAutoCompletion by property(true)
        var enableNavigation by property(true)
        var enableDiagnostics by property(true)
        var enableFormatting by property(true)
    }
}
```

### 6.2 构建与发布

```kotlin
// 构建脚本示例 (build.gradle.kts)
/*
plugins {
    id("org.jetbrains.kotlin.jvm") version "1.7.20"
    id("org.jetbrains.intellij") version "1.10.0"
}

group = "com.omnisharp"
version = "1.0.0"

repositories {
    mavenCentral()
}

dependencies {
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.13.4")
    implementation("io.projectreactor:reactor-core:3.4.23")
    testImplementation(kotlin("test"))
}

intellij {
    version.set("2022.2.3")
    type.set("IU") // IntelliJ IDEA Ultimate
    plugins.set(listOf("com.intellij.cs"))
}

tasks {
    buildSearchableOptions {
        enabled = false
    }
    
    patchPluginXml {
        sinceBuild.set("222")
        untilBuild.set("223.*")
        pluginDescription.set("OmniSharp integration for IntelliJ IDEA")
    }
    
    runIde {
        // 配置运行时参数
        jvmArgs("-Xmx2g")
    }
    
    signPlugin {
        certificateChain.set(System.getenv("CERTIFICATE_CHAIN"))
        privateKey.set(System.getenv("PRIVATE_KEY"))
        password.set(System.getenv("PRIVATE_KEY_PASSWORD"))
    }
    
    publishPlugin {
        token.set(System.getenv("PUBLISH_TOKEN"))
        channels.set(listOf("stable"))
    }
}
*/
```

## 7. 附录

### 7.1 快捷键参考

| 功能 | Windows/Linux | macOS |
|------|---------------|-------|
| 代码补全 | Ctrl+Space | Control+Space |
| 查找定义 | Ctrl+B | Command+B |
| 查找引用 | Alt+F7 | Option+F7 |
| 转到类 | Ctrl+N | Command+N |
| 转到文件 | Ctrl+Shift+N | Command+Shift+N |
| 重构此 | Ctrl+Alt+Shift+T | Control+Option+Shift+T |
| 格式化代码 | Ctrl+Alt+L | Command+Option+L |
| 快速修复 | Alt+Enter | Option+Enter |
| 重命名 | Shift+F6 | Shift+F6 |
| 提取方法 | Ctrl+Alt+M | Command+Option+M |

### 7.2 常见问题解决方案

1. **OmniSharp 服务器无法启动**
   - 检查服务器路径是否正确
   - 检查是否有足够的权限
   - 检查日志文件以获取更多信息

2. **代码补全不工作**
   - 确保服务器已连接
   - 检查文件是否正确索引
   - 尝试清除缓存并重启 IDE

3. **性能问题**
   - 增加 IDE 的内存分配
   - 禁用不必要的功能
   - 检查项目大小，大型项目可能需要更多资源

4. **导航功能不工作**
   - 确保服务器已连接
   - 检查文件是否正确索引
   - 尝试重建索引

### 7.3 资源链接

- [OmniSharp 官方文档](https://omnisharp.github.io/)
- [IntelliJ Platform SDK 文档](https://plugins.jetbrains.com/docs/intellij/welcome.html)
- [Kotlin 官方文档](https://kotlinlang.org/docs/home.html)
- [JetBrains 插件开发指南](https://plugins.jetbrains.com/docs/intellij/getting-started.html)

## 8. 总结

本阶段详细介绍了 OmniSharp-for-Intellij 插件的故障排除方法和最佳实践。通过掌握这些知识，开发者可以更有效地诊断和解决插件使用过程中遇到的问题，同时采用最佳实践提高开发效率和代码质量。

主要内容包括：

1. **故障排除流程**：系统化的问题诊断和解决方法
2. **常见问题排查**：针对连接、代码补全和性能问题的具体排查工具和方法
3. **日志系统**：日志配置和日志查看器的实现
4. **调试技巧**：远程调试和断点管理
5. **最佳实践**：开发工作流、项目组织结构和团队协作
6. **配置与部署**：插件配置和构建发布
7. **附录**：快捷键参考、常见问题解决方案和资源链接

---

本文档是 OmniSharp-for-Intellij 编辑器功能集成指南的第七阶段，也是最后一个阶段。通过完成前六个阶段的学习，开发者已经掌握了 OmniSharp-for-Intellij 插件的核心功能实现。本阶段的内容将帮助开发者在实际开发和使用过程中遇到问题时能够快速定位和解决，同时采用最佳实践确保插件的质量和可维护性。