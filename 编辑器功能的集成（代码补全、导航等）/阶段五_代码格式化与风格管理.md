# 阶段五：代码格式化与风格管理

## 1. 代码格式化功能概述

代码格式化是保持代码风格一致性的重要功能，它能够自动调整代码缩进、空格、换行等格式，使代码更加易读和美观。OmniSharp-for-Intellij 提供了强大的代码格式化功能，支持多种格式化风格和配置选项，帮助开发团队维持一致的代码风格。

### 1.1 格式化功能类型

OmniSharp-for-Intellij 支持以下主要格式化功能：

- **文档格式化**：格式化整个文档
- **选择格式化**：格式化选中的代码片段
- **自动格式化**：保存文件时自动格式化
- **格式化配置**：支持通过.editorconfig和omnisharp.json配置格式化规则
- **多种格式化风格**：支持不同的代码风格（如Mono、Visual Studio、Rider等）
- **自定义格式化规则**：允许用户自定义特定的格式化规则

## 2. 核心接口与实现

### 2.1 格式化相关接口

OmniSharp-for-Intellij 实现了 IntelliJ 平台的格式化相关接口：

```kotlin
// 代码格式化器接口
class OmniSharpCodeStyleManager(val project: Project) : CodeStyleManager {
    override fun reformatText(
        element: PsiElement,
        vararg ranges: TextRange
    ): PsiElement {
        // 实现代码格式化的逻辑
        return element
    }
    
    override fun reformatText(
        file: PsiFile,
        vararg ranges: TextRange
    ): List<PsiElement> {
        // 实现文件格式化的逻辑
        return emptyList()
    }
    
    // 其他必要的方法实现
}

// 格式化提供者接口
class OmniSharpFormattingProvider : FormattingModelProvider {
    override fun createFormattingModelForPsiFile(
        file: PsiFile,
        element: FormattingElement,
        settings: CodeStyleSettings
    ): FormattingModel {
        // 创建格式化模型
        return FormattingModelProvider.createFormattingModelForPsiFile(
            file,
            element,
            settings
        )
    }
}

// 保存时格式化处理器
class OmniSharpSaveActionHandler : SaveActionHandler {
    override fun isEnabledForDocument(
        project: Project,
        document: Document
    ): Boolean {
        // 判断是否启用保存时格式化
        return true
    }
    
    override fun execute(
        document: Document,
        file: VirtualFile,
        project: Project
    ) {
        // 执行保存时格式化
    }
}
```

### 2.2 OmniSharpFormattingService

`OmniSharpFormattingService` 是代码格式化功能的核心服务类，负责与 OmniSharp 服务器通信并处理格式化请求：

```kotlin
class OmniSharpFormattingService(project: Project) : Disposable {
    private val communicator: OmniSharpCommunicator = project.getService(OmniSharpCommunicator::class.java)
    private val formattingCache: FormattingCache = FormattingCache()
    private val virtualFileManager: VirtualFileManager = VirtualFileManager.getInstance()
    
    /**
     * 格式化文档
     * @param file 需要格式化的文件
     * @return 格式化后的内容
     */
    fun formatDocument(file: VirtualFile): Mono<String> {
        // 检查缓存
        val content = file.contentsToByteArray()
        val hash = content.contentHashCode()
        val cachedResult = formattingCache.getFormattedContent(file.path, hash)
        if (cachedResult != null) {
            return Mono.just(cachedResult)
        }
        
        // 构建请求
        val request = DocumentFormattingRequest(file)
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                // 获取格式化后的内容
                val formattedContent = response.buffer.toString(Charsets.UTF_8)
                // 更新缓存
                formattingCache.putFormattedContent(file.path, hash, formattedContent)
                formattedContent
            }
            .onErrorResume { Mono.error(it) }
    }
    
    /**
     * 格式化选中的代码片段
     * @param file 文件
     * @param range 选择范围
     * @return 格式化后的内容
     */
    fun formatSelection(file: VirtualFile, range: TextRange): Mono<String> {
        // 构建请求
        val request = RangeFormattingRequest(file, range)
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                response.buffer.toString(Charsets.UTF_8)
            }
            .onErrorResume { Mono.error(it) }
    }
    
    /**
     * 应用格式化内容到文档
     * @param document 文档
     * @param formattedContent 格式化后的内容
     */
    fun applyFormatting(document: Document, formattedContent: String) {
        ApplicationManager.getApplication().runWriteAction {
            document.setText(formattedContent)
        }
    }
    
    /**
     * 应用格式化内容到选择范围
     * @param document 文档
     * @param range 选择范围
     * @param formattedContent 格式化后的内容
     */
    fun applySelectionFormatting(document: Document, range: TextRange, formattedContent: String) {
        ApplicationManager.getApplication().runWriteAction {
            document.replaceString(range.startOffset, range.endOffset, formattedContent)
        }
    }
    
    override fun dispose() {
        formattingCache.clear()
    }
}
```

## 3. 文档格式化实现

### 3.1 格式化操作处理

```kotlin
class OmniSharpReformatCodeAction : AnAction("Reformat Code") {
    override fun actionPerformed(e: AnActionEvent) {
        val project = e.project ?: return
        val editor = e.getData(CommonDataKeys.EDITOR) ?: return
        val file = e.getData(CommonDataKeys.PSI_FILE) ?: return
        
        // 检查文件类型
        val virtualFile = file.virtualFile
        if (virtualFile == null || virtualFile.extension != "cs") {
            return
        }
        
        // 获取格式化服务
        val formattingService = project.getService(OmniSharpFormattingService::class.java)
        
        // 显示进度指示器
        ProgressManager.getInstance().runProcessWithProgressSynchronously({
            try {
                // 执行格式化
                val formattedContent = formattingService.formatDocument(virtualFile)
                    .block(Duration.ofSeconds(5)) ?: return@runProcessWithProgressSynchronously
                
                // 应用格式化内容
                formattingService.applyFormatting(editor.document, formattedContent)
                
                // 显示成功通知
                ApplicationManager.getApplication().invokeLater {
                    Notifications.Bus.notify(
                        Notification(
                            "OmniSharp",
                            "Formatting Complete",
                            "File formatted successfully",
                            NotificationType.INFORMATION
                        ),
                        project
                    )
                }
            } catch (ex: Exception) {
                // 显示错误通知
                ApplicationManager.getApplication().invokeLater {
                    Notifications.Bus.notify(
                        Notification(
                            "OmniSharp",
                            "Formatting Error",
                            "Failed to format file: ${ex.message}",
                            NotificationType.ERROR
                        ),
                        project
                    )
                }
            }
        }, "Formatting Code", false, project)
    }
    
    override fun update(e: AnActionEvent) {
        val editor = e.getData(CommonDataKeys.EDITOR)
        val file = e.getData(CommonDataKeys.PSI_FILE)
        
        // 只有在编辑器中且文件是C#文件时才启用该操作
        e.presentation.isEnabledAndVisible = 
            editor != null && file != null && file.virtualFile?.extension == "cs"
    }
}
```

### 3.2 选择格式化实现

```kotlin
class OmniSharpReformatSelectionAction : AnAction("Reformat Selection") {
    override fun actionPerformed(e: AnActionEvent) {
        val project = e.project ?: return
        val editor = e.getData(CommonDataKeys.EDITOR) ?: return
        val file = e.getData(CommonDataKeys.PSI_FILE) ?: return
        
        // 获取选择范围
        val selectionModel = editor.selectionModel
        if (!selectionModel.hasSelection()) {
            // 如果没有选择，格式化整个文档
            OmniSharpReformatCodeAction().actionPerformed(e)
            return
        }
        
        val selectionStart = selectionModel.selectionStart
        val selectionEnd = selectionModel.selectionEnd
        val selectionRange = TextRange(selectionStart, selectionEnd)
        
        // 检查文件类型
        val virtualFile = file.virtualFile
        if (virtualFile == null || virtualFile.extension != "cs") {
            return
        }
        
        // 获取格式化服务
        val formattingService = project.getService(OmniSharpFormattingService::class.java)
        
        // 显示进度指示器
        ProgressManager.getInstance().runProcessWithProgressSynchronously({
            try {
                // 执行格式化
                val formattedContent = formattingService.formatSelection(virtualFile, selectionRange)
                    .block(Duration.ofSeconds(5)) ?: return@runProcessWithProgressSynchronously
                
                // 应用格式化内容
                formattingService.applySelectionFormatting(editor.document, selectionRange, formattedContent)
                
                // 保持选择范围
                selectionModel.setSelection(selectionStart, selectionStart + formattedContent.length)
            } catch (ex: Exception) {
                // 显示错误通知
                ApplicationManager.getApplication().invokeLater {
                    Notifications.Bus.notify(
                        Notification(
                            "OmniSharp",
                            "Formatting Error",
                            "Failed to format selection: ${ex.message}",
                            NotificationType.ERROR
                        ),
                        project
                    )
                }
            }
        }, "Formatting Selection", false, project)
    }
    
    override fun update(e: AnActionEvent) {
        val editor = e.getData(CommonDataKeys.EDITOR)
        val file = e.getData(CommonDataKeys.PSI_FILE)
        
        // 只有在编辑器中且文件是C#文件时才启用该操作
        e.presentation.isEnabledAndVisible = 
            editor != null && file != null && file.virtualFile?.extension == "cs"
    }
}
```

## 4. 自动格式化实现

### 4.1 保存时自动格式化

```kotlin
class OmniSharpDocumentFormattingListener(val project: Project) : FileDocumentManagerListener {
    private val formattingService = project.getService(OmniSharpFormattingService::class.java)
    private val settings = OmniSharpFormattingSettings.getInstance(project)
    
    override fun beforeDocumentSaving(document: Document) {
        // 检查是否启用保存时格式化
        if (!settings.isFormatOnSaveEnabled) {
            return
        }
        
        // 获取文件
        val file = FileDocumentManager.getInstance().getFile(document)
        if (file == null || file.extension != "cs") {
            return
        }
        
        // 检查是否应该跳过格式化
        if (shouldSkipFormatting(file)) {
            return
        }
        
        // 执行格式化
        try {
            val formattedContent = formattingService.formatDocument(file)
                .block(Duration.ofSeconds(3)) ?: return
            
            // 应用格式化内容
            formattingService.applyFormatting(document, formattedContent)
        } catch (ex: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to format on save", ex)
        }
    }
    
    /**
     * 检查是否应该跳过格式化
     */
    private fun shouldSkipFormatting(file: VirtualFile): Boolean {
        // 检查排除的目录
        val excludedDirs = settings.getExcludedDirectories()
        for (dir in excludedDirs) {
            if (file.path.startsWith(dir)) {
                return true
            }
        }
        
        // 检查文件大小限制
        if (file.length > settings.getMaxFileSize()) {
            return true
        }
        
        return false
    }
}

class OmniSharpSaveDocumentAction : SaveDocumentAction() {
    override fun isEnabledForFile(
        project: Project,
        file: VirtualFile
    ): Boolean {
        return file.extension == "cs"
    }
    
    override fun beforeSave(
        project: Project,
        document: Document,
        file: VirtualFile
    ): Boolean {
        // 这里可以在保存前执行额外的操作
        return true
    }
    
    override fun afterSave(
        project: Project,
        document: Document,
        file: VirtualFile
    ) {
        // 这里可以在保存后执行额外的操作
    }
}
```

## 5. 格式化配置管理

### 5.1 格式化设置

```kotlin
class OmniSharpFormattingSettings(project: Project) {
    private val propertiesComponent = PropertiesComponent.getInstance(project)
    
    // 格式化风格枚举
    enum class FormattingStyle {
        DEFAULT,
        VISUAL_STUDIO,
        MONO,
        RIDER,
        CUSTOM
    }
    
    // 获取是否启用保存时格式化
    fun isFormatOnSaveEnabled(): Boolean {
        return propertiesComponent.getBoolean("omniSharp.formatting.formatOnSave", false)
    }
    
    // 设置是否启用保存时格式化
    fun setFormatOnSaveEnabled(enabled: Boolean) {
        propertiesComponent.setValue("omniSharp.formatting.formatOnSave", enabled)
    }
    
    // 获取格式化风格
    fun getFormattingStyle(): FormattingStyle {
        val styleName = propertiesComponent.getValue("omniSharp.formatting.style", "DEFAULT")
        return try {
            FormattingStyle.valueOf(styleName)
        } catch (e: IllegalArgumentException) {
            FormattingStyle.DEFAULT
        }
    }
    
    // 设置格式化风格
    fun setFormattingStyle(style: FormattingStyle) {
        propertiesComponent.setValue("omniSharp.formatting.style", style.name)
    }
    
    // 获取排除的目录
    fun getExcludedDirectories(): List<String> {
        val excludedDirs = propertiesComponent.getValue("omniSharp.formatting.excludedDirs", "")
        return if (excludedDirs.isNotEmpty()) {
            excludedDirs.split(',').map { it.trim() }
        } else {
            emptyList()
        }
    }
    
    // 设置排除的目录
    fun setExcludedDirectories(dirs: List<String>) {
        propertiesComponent.setValue("omniSharp.formatting.excludedDirs", dirs.joinToString(","))
    }
    
    // 获取最大文件大小
    fun getMaxFileSize(): Long {
        return propertiesComponent.getLong("omniSharp.formatting.maxFileSize", 1024 * 1024) // 默认1MB
    }
    
    // 设置最大文件大小
    fun setMaxFileSize(size: Long) {
        propertiesComponent.setValue("omniSharp.formatting.maxFileSize", size)
    }
    
    companion object {
        fun getInstance(project: Project): OmniSharpFormattingSettings {
            return project.getService(OmniSharpFormattingSettings::class.java)
        }
    }
}
```

### 5.2 格式化配置界面

```kotlin
class OmniSharpFormattingConfigurable : SearchableConfigurable {
    private val project: Project
    private val settings: OmniSharpFormattingSettings
    
    // UI 组件
    private val formatOnSaveCheckBox = JCheckBox("Format on save")
    private val styleComboBox = JComboBox(OmniSharpFormattingSettings.FormattingStyle.values())
    private val excludedDirsTextField = JTextField()
    private val maxFileSizeTextField = JTextField()
    
    constructor(project: Project) {
        this.project = project
        this.settings = OmniSharpFormattingSettings.getInstance(project)
    }
    
    override fun getId(): String = "omniSharp.formatting"
    
    override fun getDisplayName(): String = "Formatting"
    
    override fun createComponent(): JComponent {
        val panel = JPanel(BorderLayout())
        val contentPanel = JPanel(GridBagLayout())
        
        // 创建布局约束
        val constraints = GridBagConstraints()
        constraints.fill = GridBagConstraints.HORIZONTAL
        constraints.weightx = 1.0
        constraints.insets = Insets(5, 5, 5, 5)
        
        // 保存时格式化选项
        constraints.gridy = 0
        constraints.gridwidth = 2
        contentPanel.add(formatOnSaveCheckBox, constraints)
        
        // 格式化风格选项
        constraints.gridy = 1
        constraints.gridwidth = 1
        constraints.weightx = 0.3
        contentPanel.add(JLabel("Formatting style:"), constraints)
        constraints.weightx = 0.7
        contentPanel.add(styleComboBox, constraints)
        
        // 排除的目录选项
        constraints.gridy = 2
        constraints.weightx = 0.3
        contentPanel.add(JLabel("Excluded directories (comma-separated):"), constraints)
        constraints.weightx = 0.7
        contentPanel.add(excludedDirsTextField, constraints)
        
        // 最大文件大小选项
        constraints.gridy = 3
        constraints.weightx = 0.3
        contentPanel.add(JLabel("Max file size (bytes):"), constraints)
        constraints.weightx = 0.7
        contentPanel.add(maxFileSizeTextField, constraints)
        
        // 加载当前设置
        reset()
        
        panel.add(contentPanel, BorderLayout.NORTH)
        return panel
    }
    
    override fun reset() {
        // 加载当前设置
        formatOnSaveCheckBox.isSelected = settings.isFormatOnSaveEnabled()
        styleComboBox.selectedItem = settings.getFormattingStyle()
        excludedDirsTextField.text = settings.getExcludedDirectories().joinToString(",")
        maxFileSizeTextField.text = settings.getMaxFileSize().toString()
    }
    
    override fun isModified(): Boolean {
        // 检查是否有修改
        return formatOnSaveCheckBox.isSelected != settings.isFormatOnSaveEnabled() ||
               styleComboBox.selectedItem != settings.getFormattingStyle() ||
               excludedDirsTextField.text != settings.getExcludedDirectories().joinToString(",") ||
               maxFileSizeTextField.text.toLongOrNull() != settings.getMaxFileSize()
    }
    
    override fun apply() {
        // 应用更改
        settings.setFormatOnSaveEnabled(formatOnSaveCheckBox.isSelected)
        settings.setFormattingStyle(styleComboBox.selectedItem as OmniSharpFormattingSettings.FormattingStyle)
        
        val excludedDirs = excludedDirsTextField.text.split(',').map { it.trim() }.filter { it.isNotEmpty() }
        settings.setExcludedDirectories(excludedDirs)
        
        maxFileSizeTextField.text.toLongOrNull()?.let {
            settings.setMaxFileSize(it)
        }
    }
}
```

## 6. .editorconfig 集成

### 6.1 .editorconfig 处理器

```kotlin
class OmniSharpEditorConfigProcessor(val project: Project) {
    private val editorConfigLocator = EditorConfigLocator.getInstance()
    
    /**
     * 获取文件的 .editorconfig 设置
     * @param file 文件
     * @return .editorconfig 设置映射
     */
    fun getEditorConfigSettings(file: VirtualFile): Map<String, String> {
        val editorConfigFile = findEditorConfigFile(file)
        if (editorConfigFile == null) {
            return emptyMap()
        }
        
        return parseEditorConfigFile(editorConfigFile)
    }
    
    /**
     * 查找文件的 .editorconfig 文件
     */
    private fun findEditorConfigFile(file: VirtualFile): VirtualFile? {
        val fileDirectory = file.parent
        if (fileDirectory == null) {
            return null
        }
        
        // 向上查找 .editorconfig 文件
        var currentDir = fileDirectory
        while (currentDir != null) {
            val editorConfigFile = currentDir.findChild(".editorconfig")
            if (editorConfigFile != null && !editorConfigFile.isDirectory) {
                return editorConfigFile
            }
            
            currentDir = currentDir.parent
        }
        
        return null
    }
    
    /**
     * 解析 .editorconfig 文件
     */
    private fun parseEditorConfigFile(file: VirtualFile): Map<String, String> {
        val settings = mutableMapOf<String, String>()
        
        try {
            val content = String(file.contentsToByteArray(), Charsets.UTF_8)
            val lines = content.lines()
            
            var inCSharpSection = false
            
            for (line in lines) {
                val trimmedLine = line.trim()
                
                // 跳过注释和空行
                if (trimmedLine.isEmpty() || trimmedLine.startsWith('#')) {
                    continue
                }
                
                // 检查节
                if (trimmedLine.startsWith('[') && trimmedLine.endsWith(']')) {
                    // 检查是否为 C# 文件的节
                    inCSharpSection = trimmedLine.contains(".cs") || 
                                      trimmedLine.contains("*.cs") ||
                                      trimmedLine.contains("[*]") // 默认节
                    continue
                }
                
                // 解析设置
                if (inCSharpSection && trimmedLine.contains('=')) {
                    val parts = trimmedLine.split('=', limit = 2)
                    if (parts.size == 2) {
                        val key = parts[0].trim()
                        val value = parts[1].trim()
                        settings[key] = value
                    }
                }
            }
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to parse .editorconfig file", e)
        }
        
        return settings
    }
    
    /**
     * 将 .editorconfig 设置转换为格式化选项
     */
    fun convertToFormattingOptions(settings: Map<String, String>): FormattingOptions {
        val options = FormattingOptions()
        
        // 处理缩进设置
        settings["indent_style"]?.let {
            options.useTabs = it.equals("tab", ignoreCase = true)
        }
        
        settings["indent_size"]?.toIntOrNull()?.let {
            options.tabSize = it
        }
        
        settings["tab_width"]?.toIntOrNull()?.let {
            options.tabSize = it
        }
        
        // 处理换行设置
        settings["end_of_line"]?.let {
            when (it.lowercase()) {
                "lf" -> options.endOfLine = EndOfLine.LF
                "crlf" -> options.endOfLine = EndOfLine.CRLF
                "cr" -> options.endOfLine = EndOfLine.CR
            }
        }
        
        // 处理字符集设置
        settings["charset"]?.let {
            options.charset = it
        }
        
        // 处理其他 C# 特定设置
        settings["csharp_new_line_before_open_brace"]?.let {
            options.newLineBeforeOpenBrace = parseNewlineOption(it)
        }
        
        settings["csharp_indent_block_contents"]?.toBoolean()?.let {
            options.indentBlockContents = it
        }
        
        // 更多设置...
        
        return options
    }
    
    private fun parseNewlineOption(value: String): NewlineOption {
        return when (value.lowercase()) {
            "all" -> NewlineOption.ALL
            "none" -> NewlineOption.NONE
            "properties" -> NewlineOption.PROPERTIES
            "methods" -> NewlineOption.METHODS
            "control_blocks" -> NewlineOption.CONTROL_BLOCKS
            else -> NewlineOption.ALL
        }
    }
}

// 格式化选项类
class FormattingOptions {
    var useTabs = false
    var tabSize = 4
    var endOfLine = EndOfLine.CRLF
    var charset = "utf-8"
    var newlineBeforeOpenBrace = NewlineOption.ALL
    var indentBlockContents = true
    // 更多选项...
}

// 换行选项枚举
enum class NewlineOption {
    ALL,
    NONE,
    PROPERTIES,
    METHODS,
    CONTROL_BLOCKS
}

// 行尾枚举
enum class EndOfLine {
    LF,
    CRLF,
    CR
}
```

### 6.2 omnisharp.json 配置集成

```kotlin
class OmniSharpConfigProcessor(val project: Project) {
    private val workspaceFileIndex = ProjectRootManager.getInstance(project).fileIndex
    
    /**
     * 查找 omnisharp.json 配置文件
     */
    fun findOmniSharpConfigFile(): VirtualFile? {
        var configFile: VirtualFile? = null
        
        // 首先在项目根目录查找
        workspaceFileIndex.iterateContent({
            if (it.name == "omnisharp.json" && !it.isDirectory) {
                configFile = it
                false
            } else {
                true
            }
        }, {
            it.isDirectory && workspaceFileIndex.isInContent(it)
        })
        
        return configFile
    }
    
    /**
     * 解析 omnisharp.json 配置文件
     */
    fun parseOmniSharpConfigFile(file: VirtualFile): OmniSharpConfig? {
        try {
            val content = String(file.contentsToByteArray(), Charsets.UTF_8)
            val jsonObject = JsonParser.parseString(content).asJsonObject
            
            return OmniSharpConfig().apply {
                // 解析格式化配置
                if (jsonObject.has("FormattingOptions")) {
                    val formattingOptions = jsonObject.getAsJsonObject("FormattingOptions")
                    
                    // 解析各种格式化选项
                    formattingOptions.getBoolean("EnableEditorConfigSupport")?.let {
                        this.enableEditorConfigSupport = it
                    }
                    
                    formattingOptions.getString("NewLineFormat")?.let {
                        this.newLineFormat = when (it) {
                            "LF" -> "LF"
                            "CRLF" -> "CRLF"
                            "CR" -> "CR"
                            else -> "Auto"
                        }
                    }
                    
                    formattingOptions.getBoolean("UseTabs")?.let {
                        this.useTabs = it
                    }
                    
                    formattingOptions.getNumber("TabSize")?.let {
                        this.tabSize = it.toInt()
                    }
                    
                    // 更多格式化选项...
                }
            }
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to parse omnisharp.json file", e)
            return null
        }
    }
    
    /**
     * 获取合并后的配置
     */
    fun getMergedConfig(file: VirtualFile): FormattingOptions {
        val options = FormattingOptions()
        
        // 首先应用 omnisharp.json 配置
        val omnisharpConfigFile = findOmniSharpConfigFile()
        if (omnisharpConfigFile != null) {
            val omnisharpConfig = parseOmniSharpConfigFile(omnisharpConfigFile)
            if (omnisharpConfig != null) {
                applyOmniSharpConfig(options, omnisharpConfig)
            }
        }
        
        // 如果启用了 .editorconfig 支持，则应用 .editorconfig 配置
        val editorConfigProcessor = OmniSharpEditorConfigProcessor(project)
        val editorConfigSettings = editorConfigProcessor.getEditorConfigSettings(file)
        if (editorConfigSettings.isNotEmpty()) {
            val editorConfigOptions = editorConfigProcessor.convertToFormattingOptions(editorConfigSettings)
            applyEditorConfigOptions(options, editorConfigOptions)
        }
        
        return options
    }
    
    private fun applyOmniSharpConfig(options: FormattingOptions, config: OmniSharpConfig) {
        options.useTabs = config.useTabs
        options.tabSize = config.tabSize
        
        when (config.newLineFormat) {
            "LF" -> options.endOfLine = EndOfLine.LF
            "CRLF" -> options.endOfLine = EndOfLine.CRLF
            "CR" -> options.endOfLine = EndOfLine.CR
        }
        
        // 应用更多配置...
    }
    
    private fun applyEditorConfigOptions(target: FormattingOptions, source: FormattingOptions) {
        // 应用 .editorconfig 配置，覆盖 omnisharp.json 中的配置
        target.useTabs = source.useTabs
        target.tabSize = source.tabSize
        target.endOfLine = source.endOfLine
        target.charset = source.charset
        target.newlineBeforeOpenBrace = source.newlineBeforeOpenBrace
        target.indentBlockContents = source.indentBlockContents
        
        // 应用更多选项...
    }
}

// OmniSharp 配置类
class OmniSharpConfig {
    var enableEditorConfigSupport = true
    var newLineFormat = "Auto"
    var useTabs = false
    var tabSize = 4
    // 更多配置...
}
```

## 7. 性能优化

### 7.1 格式化缓存

```kotlin
class FormattingCache {
    private val formattedContentCache = ConcurrentHashMap<FormattingCacheKey, String>()
    private val MAX_CACHE_SIZE = 100
    
    /**
     * 获取格式化后的内容
     */
    fun getFormattedContent(filePath: String, contentHash: Int): String? {
        val key = FormattingCacheKey(filePath, contentHash)
        return formattedContentCache[key]
    }
    
    /**
     * 存储格式化后的内容
     */
    fun putFormattedContent(filePath: String, contentHash: Int, formattedContent: String) {
        manageCacheSize()
        val key = FormattingCacheKey(filePath, contentHash)
        formattedContentCache[key] = formattedContent
    }
    
    /**
     * 移除缓存项
     */
    fun removeFormattedContent(filePath: String) {
        val keysToRemove = formattedContentCache.keys.filter { it.filePath == filePath }
        keysToRemove.forEach { formattedContentCache.remove(it) }
    }
    
    /**
     * 管理缓存大小
     */
    private fun manageCacheSize() {
        if (formattedContentCache.size >= MAX_CACHE_SIZE) {
            // 移除最旧的项
            val oldestKey = formattedContentCache.keys.firstOrNull()
            oldestKey?.let { formattedContentCache.remove(it) }
        }
    }
    
    /**
     * 清除缓存
     */
    fun clear() {
        formattedContentCache.clear()
    }
    
    /**
     * 缓存键类
     */
    private data class FormattingCacheKey(val filePath: String, val contentHash: Int)
}
```

### 7.2 异步格式化

```kotlin
class OmniSharpAsyncFormatter(val project: Project) {
    private val formattingService = project.getService(OmniSharpFormattingService::class.java)
    
    /**
     * 异步格式化文档
     */
    fun formatDocumentAsync(file: VirtualFile, callback: (String?, Throwable?) -> Unit) {
        ApplicationManager.getApplication().executeOnPooledThread {
            try {
                val formattedContent = formattingService.formatDocument(file)
                    .block(Duration.ofSeconds(10))
                
                ApplicationManager.getApplication().invokeLater {
                    callback(formattedContent, null)
                }
            } catch (ex: Exception) {
                ApplicationManager.getApplication().invokeLater {
                    callback(null, ex)
                }
            }
        }
    }
    
    /**
     * 批量格式化文件
     */
    fun formatFilesAsync(files: List<VirtualFile>, progressListener: ((Int, Int) -> Unit)? = null) {
        ApplicationManager.getApplication().executeOnPooledThread {
            var completed = 0
            val total = files.size
            
            for (file in files) {
                try {
                    formattingService.formatDocument(file).block(Duration.ofSeconds(5))
                } catch (ex: Exception) {
                    Logger.getInstance("OmniSharp").warn("Failed to format file: ${file.path}", ex)
                }
                
                completed++
                progressListener?.let { listener ->
                    ApplicationManager.getApplication().invokeLater {
                        listener(completed, total)
                    }
                }
            }
        }
    }
}
```

## 8. 格式化功能配置

### 8.1 插件配置注册

```xml
<!-- 在 plugin.xml 中注册配置 -->
<extensions defaultExtensionNs="com.intellij">
  <projectConfigurable 
      instance="com.github.a793181018.omnisharpforintellij.formatting.OmniSharpFormattingConfigurable" 
      id="omniSharp.formatting" 
      displayName="OmniSharp Formatting" 
  />
  
  <formattingModelProvider implementation="com.github.a793181018.omnisharpforintellij.formatting.OmniSharpFormattingProvider" />
  
  <fileDocumentManagerListener implementation="com.github.a793181018.omnisharpforintellij.formatting.OmniSharpDocumentFormattingListener" />
</extensions>
```

### 8.2 快捷键配置

```xml
<!-- 在 plugin.xml 中配置快捷键 -->
<keymap>
  <action id="OmniSharp.ReformatCode" text="Reformat Code">
    <keyboard-shortcut first-keystroke="control alt l" keymap="$default" />
  </action>
  <action id="OmniSharp.ReformatSelection" text="Reformat Selection">
    <keyboard-shortcut first-keystroke="control alt i" keymap="$default" />
  </action>
</keymap>
```

## 9. 常见问题与解决方案

### 9.1 格式化不生效

**问题症状**：执行格式化操作后，代码格式没有变化。

**可能原因**：
- OmniSharp 服务器未启动或已崩溃
- 配置文件不正确
- 代码有语法错误
- 格式化规则冲突

**解决方案**：
1. 检查 OmniSharp 服务器状态
2. 验证配置文件格式
3. 修复代码中的语法错误
4. 检查格式化规则配置

### 9.2 格式化性能问题

**问题症状**：格式化大型文件时速度很慢。

**可能原因**：
- 文件过大
- 服务器响应慢
- 缓存配置不当

**解决方案**：
1. 增加最大文件大小限制
2. 优化服务器性能
3. 增加缓存大小
4. 使用选择格式化代替文档格式化

### 9.3 格式化风格不一致

**问题症状**：不同文件的格式化风格不一致。

**可能原因**：
- 缺少全局配置文件
- .editorconfig 配置不一致
- 格式化规则冲突

**解决方案**：
1. 在项目根目录创建统一的配置文件
2. 确保所有 .editorconfig 文件配置一致
3. 检查并解决规则冲突

## 10. 下一步

完成代码格式化与风格管理功能集成后，可以继续学习以下阶段的内容：

1. **阶段六：高级功能与性能优化** - 学习如何实现高级功能和性能优化
2. **阶段七：故障排除与最佳实践** - 学习如何处理常见问题和实施最佳实践

---

本文档是 OmniSharp-for-Intellij 编辑器功能集成指南的第五阶段，详细介绍了代码格式化与风格管理功能的实现原理、核心接口、文档格式化、自动格式化、格式化配置、与.editorconfig集成和性能优化策略。通过本阶段的学习，开发者应该能够理解和实现高质量的代码格式化功能。