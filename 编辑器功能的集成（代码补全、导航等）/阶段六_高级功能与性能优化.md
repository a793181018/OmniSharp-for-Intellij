# 阶段六：高级功能与性能优化

## 1. 高级功能概述

OmniSharp-for-Intellij 不仅提供了基本的编辑器功能，还支持多种高级功能，这些功能可以显著提升开发效率和代码质量。同时，性能优化对于保持插件的响应性和用户体验至关重要。本阶段将详细介绍如何实现这些高级功能并进行性能优化。

### 1.1 主要高级功能

OmniSharp-for-Intellij 支持的主要高级功能包括：

- **智能重构**：代码重命名、提取方法、内联变量等
- **实时协作编辑**：多用户同时编辑同一文件
- **高级代码分析**：代码复杂度分析、依赖图生成
- **代码模板与片段**：自定义代码模板和代码片段
- **版本控制系统集成**：与Git等版本控制系统的深度集成
- **构建系统集成**：与MSBuild、dotnet CLI等构建系统的集成

## 2. 智能重构功能

### 2.1 重构相关接口

OmniSharp-for-Intellij 实现了 IntelliJ 平台的重构相关接口：

```kotlin
// 重构处理器接口
class OmniSharpRefactoringSupportProvider(project: Project) : RefactoringSupportProvider {
    private val project = project
    
    override fun isMemberSupported(refactoringClass: Class<out RefactoringActionHandler>, member: PsiMember): Boolean {
        // 检查成员是否支持特定重构操作
        return true
    }
    
    override fun isElementSupported(actionHandler: RefactoringActionHandler, element: PsiElement): Boolean {
        // 检查元素是否支持特定重构操作
        return true
    }
}

// 重命名重构处理器
class OmniSharpRenameHandler(project: Project) : RenamePsiElementProcessor() {
    private val communicator = project.getService(OmniSharpCommunicator::class.java)
    
    override fun canProcessElement(element: PsiElement): Boolean {
        // 检查元素是否可以重命名
        return element is PsiNamedElement && element.containingFile.virtualFile?.extension == "cs"
    }
    
    override fun renameElement(element: PsiElement, newName: String, usages: Array<PsiReference>, listener: RefactoringElementListener?) {
        // 执行重命名操作
        if (element is PsiNamedElement) {
            // 通知 OmniSharp 服务器执行重命名
            val request = RenameRequest(element, newName, usages)
            communicator.sendRequest(request)
                .doOnSuccess { 
                    // 更新本地代码
                    super.renameElement(element, newName, usages, listener)
                }
                .block()
        }
    }
}

// 提取方法重构处理器
class OmniSharpExtractMethodHandler(project: Project) : ExtractMethodHandlerBase() {
    private val project = project
    
    override fun isAvailableForLanguage(language: Language): Boolean {
        return language.id == "CSHARP"
    }
    
    override fun getHandler(smartPsiElementPointer: SmartPsiElementPointer<PsiElement>, project: Project, editor: Editor): RefactoringActionHandler? {
        // 创建重构处理器
        return OmniSharpExtractMethodHandler(project)
    }
    
    override fun createDialog(editor: Editor, project: Project, elements: List<PsiElement>, defaultMethodName: String): RefactoringDialog {
        // 创建提取方法对话框
        return OmniSharpExtractMethodDialog(project, editor, elements, defaultMethodName)
    }
}
```

### 2.2 重构服务实现

```kotlin
class OmniSharpRefactoringService(project: Project) {
    private val communicator = project.getService(OmniSharpCommunicator::class.java)
    private val project = project
    
    /**
     * 执行重命名重构
     */
    fun rename(element: PsiElement, newName: String): Mono<Boolean> {
        // 构建请求
        val request = RenameRequest(
            filePath = element.containingFile.virtualFile.path,
            line = getLineNumber(element),
            column = getColumnNumber(element),
            renameTo = newName
        )
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                // 应用重命名变更
                applyRenameChanges(response)
                true
            }
            .onErrorResume { Mono.just(false) }
    }
    
    /**
     * 提取方法重构
     */
    fun extractMethod(file: VirtualFile, selection: TextRange, methodName: String): Mono<Boolean> {
        // 构建请求
        val request = ExtractMethodRequest(
            filePath = file.path,
            selectionStart = selection.startOffset,
            selectionEnd = selection.endOffset,
            methodName = methodName
        )
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                // 应用提取方法变更
                applyExtractMethodChanges(response)
                true
            }
            .onErrorResume { Mono.just(false) }
    }
    
    /**
     * 内联变量重构
     */
    fun inlineVariable(element: PsiElement): Mono<Boolean> {
        // 构建请求
        val request = InlineVariableRequest(
            filePath = element.containingFile.virtualFile.path,
            line = getLineNumber(element),
            column = getColumnNumber(element)
        )
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                // 应用内联变量变更
                applyInlineVariableChanges(response)
                true
            }
            .onErrorResume { Mono.just(false) }
    }
    
    /**
     * 应用重命名变更
     */
    private fun applyRenameChanges(response: RenameResponse) {
        ApplicationManager.getApplication().runWriteAction {
            // 应用所有重命名变更
            response.changes.forEach { change ->
                val file = LocalFileSystem.getInstance().findFileByPath(change.fileName)
                if (file != null) {
                    val document = FileDocumentManager.getInstance().getDocument(file)
                    if (document != null) {
                        // 应用重命名
                        change.changes.forEach { 
                            document.replaceString(it.start, it.end, change.renameTo)
                        }
                    }
                }
            }
        }
    }
    
    /**
     * 获取元素的行号
     */
    private fun getLineNumber(element: PsiElement): Int {
        val document = FileDocumentManager.getInstance().getDocument(element.containingFile.virtualFile)
        return document?.getLineNumber(element.textOffset) ?: 0
    }
    
    /**
     * 获取元素的列号
     */
    private fun getColumnNumber(element: PsiElement): Int {
        val document = FileDocumentManager.getInstance().getDocument(element.containingFile.virtualFile)
        val lineNumber = document?.getLineNumber(element.textOffset) ?: 0
        val lineStartOffset = document?.getLineStartOffset(lineNumber) ?: 0
        return element.textOffset - lineStartOffset
    }
    
    // 其他辅助方法...
}
```

## 3. 实时协作编辑

### 3.1 协作编辑接口

```kotlin
// 协作编辑管理器
class OmniSharpCollaborationManager(project: Project) : Disposable {
    private val project = project
    private val participants = mutableListOf<Collaborator>()
    private val changes = ConcurrentLinkedQueue<DocumentChange>()
    private val collaborationClient = project.getService(OmniSharpCollaborationClient::class.java)
    
    /**
     * 加入协作会话
     */
    fun joinSession(sessionId: String, userName: String, userColor: String): CompletableFuture<Boolean> {
        return collaborationClient.joinSession(sessionId, userName, userColor)
            .thenApply {\ success ->
                if (success) {
                    // 注册事件监听器
                    registerEventListeners()
                }
                success
            }
    }
    
    /**
     * 离开协作会话
     */
    fun leaveSession(): CompletableFuture<Boolean> {
        return collaborationClient.leaveSession()
            .thenApply {\ success ->
                if (success) {
                    // 移除事件监听器
                    unregisterEventListeners()
                    // 清除参与者
                    participants.clear()
                    // 清除变更队列
                    changes.clear()
                }
                success
            }
    }
    
    /**
     * 发送文档变更
     */
    fun sendDocumentChange(file: VirtualFile, change: TextRange, newText: String) {
        val documentChange = DocumentChange(
            fileName = file.path,
            startOffset = change.startOffset,
            endOffset = change.endOffset,
            newText = newText,
            timestamp = System.currentTimeMillis()
        )
        
        collaborationClient.sendDocumentChange(documentChange)
    }
    
    /**
     * 注册事件监听器
     */
    private fun registerEventListeners() {
        // 注册文档变更监听器
        DocumentManager.getInstance().addDocumentListener(object : DocumentListener {
            override fun documentChanged(event: DocumentEvent) {
                val file = FileDocumentManager.getInstance().getFile(event.document)
                if (file != null && file.extension == "cs") {
                    sendDocumentChange(file, TextRange(event.offset, event.offset + event.oldLength), event.newFragment.toString())
                }
            }
        }, this)
        
        // 注册光标移动监听器
        // ...
    }
    
    /**
     * 处理接收到的文档变更
     */
    fun handleDocumentChange(change: DocumentChange) {
        ApplicationManager.getApplication().invokeLater {
            ApplicationManager.getApplication().runWriteAction {
                val file = LocalFileSystem.getInstance().findFileByPath(change.fileName)
                if (file != null) {
                    val document = FileDocumentManager.getInstance().getDocument(file)
                    if (document != null) {
                        document.replaceString(change.startOffset, change.endOffset, change.newText)
                    }
                }
            }
        }
    }
    
    /**
     * 获取所有协作者
     */
    fun getCollaborators(): List<Collaborator> {
        return participants.toList()
    }
    
    override fun dispose() {
        // 清理资源
        unregisterEventListeners()
        collaborationClient.disconnect()
    }
}

// 协作者类
data class Collaborator(val id: String, val name: String, val color: String)

// 文档变更类
data class DocumentChange(
    val fileName: String,
    val startOffset: Int,
    val endOffset: Int,
    val newText: String,
    val timestamp: Long
)
```

### 3.2 协作客户端实现

```kotlin
class OmniSharpCollaborationClient(project: Project) {
    private val project = project
    private var webSocket: WebSocket? = null
    private var sessionId: String? = null
    private val messageQueue = ConcurrentLinkedQueue<CollaborationMessage>()
    private val messageHandler = CollaborationMessageHandler(project)
    
    /**
     * 连接到协作服务器
     */
    fun connect(serverUrl: String): CompletableFuture<Boolean> {
        val future = CompletableFuture<Boolean>()
        
        try {
            val client = StandardWebSocketClient()
            client.doHandshake(object : WebSocketHandlerAdapter() {
                override fun afterConnectionEstablished(ws: WebSocket) {
                    webSocket = ws
                    // 开始处理消息队列
                    startMessageProcessing()
                    future.complete(true)
                }
                
                override fun handleTextMessage(ws: WebSocket, message: TextMessage) {
                    // 处理接收到的消息
                    messageHandler.handleMessage(message.payload)
                }
                
                override fun afterConnectionClosed(ws: WebSocket, statusCode: Int, reason: String) {
                    webSocket = null
                    // 处理连接关闭
                    future.complete(false)
                }
            }, serverUrl)
        } catch (e: Exception) {
            future.completeExceptionally(e)
        }
        
        return future
    }
    
    /**
     * 加入会话
     */
    fun joinSession(sessionId: String, userName: String, userColor: String): CompletableFuture<Boolean> {
        this.sessionId = sessionId
        val message = JoinSessionMessage(sessionId, userName, userColor)
        return sendMessage(message)
    }
    
    /**
     * 离开会话
     */
    fun leaveSession(): CompletableFuture<Boolean> {
        val message = LeaveSessionMessage(sessionId!!)
        return sendMessage(message)
    }
    
    /**
     * 发送文档变更
     */
    fun sendDocumentChange(change: DocumentChange) {
        val message = DocumentChangeMessage(sessionId!!, change)
        sendMessage(message)
    }
    
    /**
     * 发送消息
     */
    private fun sendMessage(message: CollaborationMessage): CompletableFuture<Boolean> {
        val future = CompletableFuture<Boolean>()
        messageQueue.add(message)
        future.complete(true)
        return future
    }
    
    /**
     * 开始处理消息队列
     */
    private fun startMessageProcessing() {
        Executors.newSingleThreadExecutor().submit {
            while (true) {
                val message = messageQueue.poll()
                if (message != null && webSocket?.isOpen == true) {
                    try {
                        val json = ObjectMapper().writeValueAsString(message)
                        webSocket?.sendMessage(TextMessage(json))
                    } catch (e: Exception) {
                        Logger.getInstance("OmniSharp").error("Failed to send collaboration message", e)
                    }
                }
                Thread.sleep(10)
            }
        }
    }
    
    /**
     * 断开连接
     */
    fun disconnect() {
        webSocket?.close()
        webSocket = null
    }
}

// 协作消息基类
sealed class CollaborationMessage(val type: String)

// 加入会话消息
class JoinSessionMessage(
    val sessionId: String,
    val userName: String,
    val userColor: String
) : CollaborationMessage("joinSession")

// 离开会话消息
class LeaveSessionMessage(val sessionId: String) : CollaborationMessage("leaveSession")

// 文档变更消息
class DocumentChangeMessage(
    val sessionId: String,
    val change: DocumentChange
) : CollaborationMessage("documentChange")

// 协作消息处理器
class CollaborationMessageHandler(project: Project) {
    private val collaborationManager = project.getService(OmniSharpCollaborationManager::class.java)
    
    /**
     * 处理接收到的消息
     */
    fun handleMessage(message: String) {
        try {
            val jsonNode = ObjectMapper().readTree(message)
            val type = jsonNode.get("type").asText()
            
            when (type) {
                "documentChange" -> handleDocumentChange(jsonNode)
                "userJoined" -> handleUserJoined(jsonNode)
                "userLeft" -> handleUserLeft(jsonNode)
                // 处理其他类型的消息
            }
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").error("Failed to handle collaboration message", e)
        }
    }
    
    /**
     * 处理文档变更消息
     */
    private fun handleDocumentChange(jsonNode: JsonNode) {
        val changeNode = jsonNode.get("change")
        val change = DocumentChange(
            fileName = changeNode.get("fileName").asText(),
            startOffset = changeNode.get("startOffset").asInt(),
            endOffset = changeNode.get("endOffset").asInt(),
            newText = changeNode.get("newText").asText(),
            timestamp = changeNode.get("timestamp").asLong()
        )
        
        collaborationManager.handleDocumentChange(change)
    }
    
    // 处理其他类型的消息...
}
```

## 4. 高级代码分析

### 4.1 代码分析服务

```kotlin
class OmniSharpCodeAnalysisService(project: Project) {
    private val communicator = project.getService(OmniSharpCommunicator::class.java)
    private val project = project
    
    /**
     * 分析代码复杂度
     */
    fun analyzeComplexity(file: VirtualFile): Mono<ComplexityAnalysisResult> {
        val request = CodeComplexityRequest(file.path)
        
        return communicator.sendRequest(request)
            .map { response ->
                parseComplexityResponse(response)
            }
    }
    
    /**
     * 生成依赖图
     */
    fun generateDependencyGraph(): Mono<DependencyGraph> {
        val request = GenerateDependencyGraphRequest()
        
        return communicator.sendRequest(request)
            .map { response ->
                parseDependencyGraphResponse(response)
            }
    }
    
    /**
     * 查找潜在的代码问题
     */
    fun findPotentialIssues(file: VirtualFile): Mono<List<CodeIssue>> {
        val request = FindPotentialIssuesRequest(file.path)
        
        return communicator.sendRequest(request)
            .map { response ->
                parsePotentialIssuesResponse(response)
            }
    }
    
    /**
     * 解析复杂度分析响应
     */
    private fun parseComplexityResponse(response: ClientResponse): ComplexityAnalysisResult {
        val json = response.buffer.toString(Charsets.UTF_8)
        val jsonNode = ObjectMapper().readTree(json)
        
        val methods = mutableListOf<MethodComplexity>()
        
        jsonNode.get("methods").forEach {\ methodNode ->
            val method = MethodComplexity(
                name = methodNode.get("name").asText(),
                cyclomaticComplexity = methodNode.get("cyclomaticComplexity").asInt(),
                cognitiveComplexity = methodNode.get("cognitiveComplexity").asInt(),
                linesOfCode = methodNode.get("linesOfCode").asInt(),
                startLine = methodNode.get("startLine").asInt(),
                endLine = methodNode.get("endLine").asInt()
            )
            methods.add(method)
        }
        
        return ComplexityAnalysisResult(
            averageComplexity = jsonNode.get("averageComplexity").asDouble(),
            maximumComplexity = jsonNode.get("maximumComplexity").asInt(),
            methods = methods
        )
    }
    
    // 其他解析方法...
}

// 复杂度分析结果类
data class ComplexityAnalysisResult(
    val averageComplexity: Double,
    val maximumComplexity: Int,
    val methods: List<MethodComplexity>
)

// 方法复杂度类
data class MethodComplexity(
    val name: String,
    val cyclomaticComplexity: Int,
    val cognitiveComplexity: Int,
    val linesOfCode: Int,
    val startLine: Int,
    val endLine: Int
)

// 依赖图类
data class DependencyGraph(
    val nodes: List<DependencyNode>,
    val edges: List<DependencyEdge>
)

// 依赖节点类
data class DependencyNode(
    val id: String,
    val name: String,
    val type: String // project, namespace, class, etc.
)

// 依赖边类
data class DependencyEdge(
    val source: String,
    val target: String,
    val type: String // reference, inheritance, etc.
)

// 代码问题类
data class CodeIssue(
    val message: String,
    val severity: String,
    val startLine: Int,
    val startColumn: Int,
    val endLine: Int,
    val endColumn: Int,
    val suggestion: String? = null
)
```

### 4.2 代码分析 UI 组件

```kotlin
class OmniSharpCodeAnalysisToolWindowFactory : ToolWindowFactory {
    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        val toolWindowContent = OmniSharpCodeAnalysisToolWindowContent(project)
        toolWindow.contentManager.addContent(toolWindowContent)
    }
    
    override fun shouldBeAvailable(project: Project): Boolean {
        // 只有当项目包含 C# 文件时才可用
        return hasCSharpFiles(project)
    }
    
    private fun hasCSharpFiles(project: Project): Boolean {
        var hasCSharpFiles = false
        
        ProjectFileIndex.SERVICE.getInstance(project).iterateContent {\ file ->
            if (file.extension == "cs") {
                hasCSharpFiles = true
                false
            } else {
                true
            }
        }
        
        return hasCSharpFiles
    }
}

class OmniSharpCodeAnalysisToolWindowContent(project: Project) : ToolWindowContent(project) {
    private val codeAnalysisService = project.getService(OmniSharpCodeAnalysisService::class.java)
    private val analysisPanel = JPanel(BorderLayout())
    private val resultsTabbedPane = JTabbedPane()
    private val complexityTab = JPanel(BorderLayout())
    private val dependenciesTab = JPanel(BorderLayout())
    private val issuesTab = JPanel(BorderLayout())
    
    init {
        // 初始化 UI
        initUI()
        
        // 设置内容
        analysisPanel.add(resultsTabbedPane, BorderLayout.CENTER)
        component = analysisPanel
    }
    
    private fun initUI() {
        // 初始化标签页
        resultsTabbedPane.addTab("Complexity", complexityTab)
        resultsTabbedPane.addTab("Dependencies", dependenciesTab)
        resultsTabbedPane.addTab("Issues", issuesTab)
        
        // 初始化复杂度分析面板
        initComplexityPanel()
        
        // 初始化依赖图面板
        initDependenciesPanel()
        
        // 初始化代码问题面板
        initIssuesPanel()
    }
    
    private fun initComplexityPanel() {
        val complexityToolbar = JToolBar()
        complexityTab.add(complexityToolbar, BorderLayout.NORTH)
        
        val analyzeButton = JButton("Analyze Current File")
        analyzeButton.addActionListener {
            analyzeCurrentFileComplexity()
        }
        complexityToolbar.add(analyzeButton)
        
        val complexityTable = JTable(ComplexityTableModel())
        complexityTab.add(JScrollPane(complexityTable), BorderLayout.CENTER)
    }
    
    private fun analyzeCurrentFileComplexity() {
        val editor = FileEditorManager.getInstance(project).selectedTextEditor
        if (editor != null) {
            val file = FileDocumentManager.getInstance().getFile(editor.document)
            if (file != null && file.extension == "cs") {
                ProgressManager.getInstance().runProcessWithProgressSynchronously({
                    try {
                        val result = codeAnalysisService.analyzeComplexity(file).block()
                        if (result != null) {
                            updateComplexityTable(result)
                        }
                    } catch (e: Exception) {
                        Logger.getInstance("OmniSharp").error("Failed to analyze file complexity", e)
                    }
                }, "Analyzing Code Complexity", false, project)
            }
        }
    }
    
    // 其他初始化和更新方法...
}
```

## 5. 缓存策略

### 5.1 多级缓存系统

```kotlin
class OmniSharpCacheManager(project: Project) : Disposable {
    private val project = project
    private val memoryCache = ConcurrentHashMap<CacheKey, Any>()
    private val diskCache = DiskLruCache.create(
        File(project.basePath + "/.omnisharp/cache"),
        1,
        100,
        10 * 1024 * 1024 // 10MB 缓存
    )
    private val cacheLock = ReentrantReadWriteLock()
    
    /**
     * 从缓存获取数据
     */
    fun <T> get(key: String, type: Class<T>): T? {
        val cacheKey = CacheKey(key, type)
        
        // 先从内存缓存获取
        memoryCache[cacheKey]?.let { return type.cast(it) }
        
        // 再从磁盘缓存获取
        try {
            diskCache.get(key)?.let { snapshot ->
                snapshot.getInputStream(0).use { inputStream ->
                    val data = ObjectMapper().readValue(inputStream, type)
                    // 更新内存缓存
                    memoryCache[cacheKey] = data
                    return data
                }
            }
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to read from disk cache", e)
        }
        
        return null
    }
    
    /**
     * 将数据存入缓存
     */
    fun put(key: String, value: Any) {
        val cacheKey = CacheKey(key, value.javaClass)
        
        // 更新内存缓存
        memoryCache[cacheKey] = value
        
        // 更新磁盘缓存
        try {
            diskCache.edit(key)?.let { editor ->
                editor.newOutputStream(0).use {\ outputStream ->
                    ObjectMapper().writeValue(outputStream, value)
                    editor.commit()
                }
            }
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to write to disk cache", e)
        }
    }
    
    /**
     * 从缓存中移除数据
     */
    fun remove(key: String, type: Class<*>? = null) {
        if (type != null) {
            val cacheKey = CacheKey(key, type)
            memoryCache.remove(cacheKey)
        } else {
            // 移除所有类型的键
            memoryCache.keys.removeIf { it.key == key }
        }
        
        try {
            diskCache.remove(key)
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to remove from disk cache", e)
        }
    }
    
    /**
     * 清除缓存
     */
    fun clear() {
        memoryCache.clear()
        try {
            diskCache.delete()
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to clear disk cache", e)
        }
    }
    
    /**
     * 缓存键类
     */
    private data class CacheKey(val key: String, val type: Class<*>) {
        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (javaClass != other?.javaClass) return false
            
            other as CacheKey
            
            if (key != other.key) return false
            if (type != other.type) return false
            
            return true
        }
        
        override fun hashCode(): Int {
            var result = key.hashCode()
            result = 31 * result + type.hashCode()
            return result
        }
    }
    
    override fun dispose() {
        try {
            diskCache.close()
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to close disk cache", e)
        }
        memoryCache.clear()
    }
}
```

### 5.2 智能缓存失效策略

```kotlin
class OmniSharpSmartCacheInvalidator(project: Project) {
    private val project = project
    private val cacheManager = project.getService(OmniSharpCacheManager::class.java)
    private val modificationTracker = AtomicLong()
    
    init {
        // 注册文件修改监听器
        registerFileModificationListener()
        
        // 注册项目结构变更监听器
        registerProjectStructureListener()
    }
    
    /**
     * 注册文件修改监听器
     */
    private fun registerFileModificationListener() {
        VirtualFileManager.getInstance().addVirtualFileListener(object : VirtualFileListener {
            override fun contentsChanged(event: VirtualFileEvent) {
                if (event.file.extension == "cs") {
                    // 使相关缓存失效
                    invalidateRelatedCaches(event.file)
                }
            }
            
            override fun fileCreated(event: VirtualFileEvent) {
                if (event.file.extension == "cs") {
                    // 使相关缓存失效
                    invalidateRelatedCaches(event.file.parent)
                }
            }
            
            override fun fileDeleted(event: VirtualFileEvent) {
                if (event.file.extension == "cs") {
                    // 使相关缓存失效
                    invalidateRelatedCaches(event.file.parent)
                }
            }
        })
    }
    
    /**
     * 注册项目结构变更监听器
     */
    private fun registerProjectStructureListener() {
        ProjectRootManager.getInstance(project).addModelListener(object : ProjectModelListener {
            override fun modulesChanged() {
                // 使项目相关缓存失效
                invalidateProjectCaches()
            }
        })
    }
    
    /**
     * 使相关缓存失效
     */
    private fun invalidateRelatedCaches(file: VirtualFile) {
        val filePath = file.path
        
        // 使文件特定缓存失效
        cacheManager.remove("completion_$filePath")
        cacheManager.remove("diagnostics_$filePath")
        cacheManager.remove("formatting_$filePath")
        
        // 如果是类文件，使相关类的缓存失效
        if (file.extension == "cs") {
            val className = file.nameWithoutExtension
            cacheManager.remove("class_info_$className")
        }
        
        // 更新修改计数器
        modificationTracker.incrementAndGet()
    }
    
    /**
     * 使项目缓存失效
     */
    private fun invalidateProjectCaches() {
        // 使项目级缓存失效
        cacheManager.remove("project_symbols")
        cacheManager.remove("dependency_graph")
        cacheManager.remove("solution_info")
        
        // 更新修改计数器
        modificationTracker.incrementAndGet()
    }
    
    /**
     * 获取当前修改计数
     */
    fun getModificationCount(): Long {
        return modificationTracker.get()
    }
    
    /**
     * 检查缓存是否有效
     */
    fun isCacheValid(lastModificationCount: Long): Boolean {
        return lastModificationCount == modificationTracker.get()
    }
}
```

## 6. 并发处理与异步操作

### 6.1 异步任务管理器

```kotlin
class OmniSharpTaskManager(project: Project) {
    private val project = project
    private val taskExecutor = Executors.newFixedThreadPool(
        Runtime.getRuntime().availableProcessors() * 2
    )
    private val taskScheduler = Executors.newScheduledThreadPool(1)
    private val activeTasks = ConcurrentHashMap<String, Future<*>>()
    private val taskLock = ReentrantLock()
    
    /**
     * 提交任务
     */
    fun <T> submitTask(taskId: String, task: Callable<T>): CompletableFuture<T> {
        val future = CompletableFuture<T>()
        
        taskLock.lock()
        try {
            // 取消之前相同 ID 的任务
            activeTasks.remove(taskId)?.cancel(true)
            
            // 提交新任务
            val taskFuture = taskExecutor.submit { 
                try {
                    val result = task.call()
                    future.complete(result)
                } catch (e: Exception) {
                    future.completeExceptionally(e)
                } finally {
                    activeTasks.remove(taskId)
                }
            }
            
            // 记录活动任务
            activeTasks[taskId] = taskFuture
        } finally {
            taskLock.unlock()
        }
        
        return future
    }
    
    /**
     * 提交定时任务
     */
    fun scheduleTask(delay: Long, unit: TimeUnit, task: Runnable): ScheduledFuture<*> {
        return taskScheduler.schedule(task, delay, unit)
    }
    
    /**
     * 提交周期性任务
     */
    fun scheduleAtFixedRate(initialDelay: Long, period: Long, unit: TimeUnit, task: Runnable): ScheduledFuture<*> {
        return taskScheduler.scheduleAtFixedRate(task, initialDelay, period, unit)
    }
    
    /**
     * 取消任务
     */
    fun cancelTask(taskId: String): Boolean {
        taskLock.lock()
        try {
            return activeTasks.remove(taskId)?.cancel(true) ?: false
        } finally {
            taskLock.unlock()
        }
    }
    
    /**
     * 取消所有任务
     */
    fun cancelAllTasks() {
        taskLock.lock()
        try {
            activeTasks.values.forEach { it.cancel(true) }
            activeTasks.clear()
        } finally {
            taskLock.unlock()
        }
    }
    
    /**
     * 获取活动任务数
     */
    fun getActiveTaskCount(): Int {
        return activeTasks.size
    }
    
    /**
     * 关闭任务管理器
     */
    fun shutdown() {
        cancelAllTasks()
        taskExecutor.shutdown()
        taskScheduler.shutdown()
    }
}
```

### 6.2 异步操作封装

```kotlin
class OmniSharpAsyncOperation<T>(private val operation: () -> T) {
    private val listeners = mutableListOf<AsyncOperationListener<T>>()
    private var state: AsyncOperationState<T> = AsyncOperationState.Pending
    private val stateLock = ReentrantLock()
    
    /**
     * 添加操作监听器
     */
    fun addListener(listener: AsyncOperationListener<T>): OmniSharpAsyncOperation<T> {
        stateLock.lock()
        try {
            listeners.add(listener)
            
            // 如果操作已经完成，立即通知监听器
            when (state) {
                is AsyncOperationState.Success -> listener.onSuccess((state as AsyncOperationState.Success).result)
                is AsyncOperationState.Failure -> listener.onFailure((state as AsyncOperationState.Failure).exception)
                else -> {}
            }
        } finally {
            stateLock.unlock()
        }
        
        return this
    }
    
    /**
     * 执行操作
     */
    fun execute(): OmniSharpAsyncOperation<T> {
        Executors.newSingleThreadExecutor().submit {
            try {
                val result = operation()
                complete(result)
            } catch (e: Exception) {
                fail(e)
            }
        }
        
        return this
    }
    
    /**
     * 操作成功完成
     */
    private fun complete(result: T) {
        stateLock.lock()
        try {
            state = AsyncOperationState.Success(result)
            // 通知所有监听器
            listeners.forEach { it.onSuccess(result) }
        } finally {
            stateLock.unlock()
        }
    }
    
    /**
     * 操作失败
     */
    private fun fail(exception: Exception) {
        stateLock.lock()
        try {
            state = AsyncOperationState.Failure(exception)
            // 通知所有监听器
            listeners.forEach { it.onFailure(exception) }
        } finally {
            stateLock.unlock()
        }
    }
    
    /**
     * 获取操作状态
     */
    fun getState(): AsyncOperationState<T> {
        stateLock.lock()
        try {
            return state
        } finally {
            stateLock.unlock()
        }
    }
}

// 异步操作监听器接口
interface AsyncOperationListener<T> {
    fun onSuccess(result: T)
    fun onFailure(exception: Exception)
}

// 异步操作状态密封类
sealed class AsyncOperationState<T>
object Pending : AsyncOperationState<Nothing>()
data class Success<T>(val result: T) : AsyncOperationState<T>()
data class Failure<T>(val exception: Exception) : AsyncOperationState<T>()

// 异步操作扩展函数
fun <T> executeAsync(operation: () -> T): OmniSharpAsyncOperation<T> {
    return OmniSharpAsyncOperation(operation).execute()
}
```

## 7. 懒加载与延迟初始化

### 7.1 懒加载服务

```kotlin
class OmniSharpLazyServices {
    // 使用 Kotlin 的 lazy 委托实现懒加载
    val heavyService: HeavyService by lazy {
        createHeavyService()
    }
    
    val expensiveResource: ExpensiveResource by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
        loadExpensiveResource()
    }
    
    private fun createHeavyService(): HeavyService {
        // 初始化重型服务
        return HeavyService()
    }
    
    private fun loadExpensiveResource(): ExpensiveResource {
        // 加载昂贵的资源
        return ExpensiveResource()
    }
}

// 延迟初始化管理器
class OmniSharpLazyInitializer {
    private val initializedServices = ConcurrentHashMap<String, Any>()
    private val initializationLock = ReentrantLock()
    
    /**
     * 懒加载服务
     */
    fun <T> getOrInitializeService(serviceId: String, initializer: () -> T): T {
        // 双重检查锁定模式
        initializedServices[serviceId]?.let { return it as T }
        
        initializationLock.lock()
        try {
            initializedServices[serviceId]?.let { return it as T }
            
            val service = initializer()
            initializedServices[serviceId] = service
            return service
        } finally {
            initializationLock.unlock()
        }
    }
    
    /**
     * 检查服务是否已初始化
     */
    fun isServiceInitialized(serviceId: String): Boolean {
        return initializedServices.containsKey(serviceId)
    }
    
    /**
     * 重置服务初始化状态
     */
    fun resetService(serviceId: String) {
        initializationLock.lock()
        try {
            initializedServices.remove(serviceId)
        } finally {
            initializationLock.unlock()
        }
    }
}
```

### 7.2 延迟加载 UI 组件

```kotlin
class OmniSharpLazyToolWindowFactory : ToolWindowFactory {
    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        // 使用延迟加载内容
        toolWindow.contentManager.addContent(LazyToolWindowContent(project, toolWindow))
    }
}

class LazyToolWindowContent(project: Project, toolWindow: ToolWindow) : ToolWindowContent(project) {
    private val contentPanel = JPanel(BorderLayout())
    private val loadingPanel = createLoadingPanel()
    private var contentInitialized = false
    
    init {
        // 初始显示加载面板
        contentPanel.add(loadingPanel, BorderLayout.CENTER)
        component = contentPanel
        
        // 延迟初始化实际内容
        scheduleContentInitialization()
    }
    
    /**
     * 创建加载面板
     */
    private fun createLoadingPanel(): JComponent {
        val panel = JPanel(BorderLayout())
        val loadingLabel = JLabel("Loading content...")
        loadingLabel.horizontalAlignment = SwingConstants.CENTER
        panel.add(loadingLabel, BorderLayout.CENTER)
        return panel
    }
    
    /**
     * 调度内容初始化
     */
    private fun scheduleContentInitialization() {
        // 延迟初始化，避免阻塞 UI 线程
        SwingUtilities.invokeLater {
            ApplicationManager.getApplication().executeOnPooledThread {
                val actualContent = initializeContent()
                
                ApplicationManager.getApplication().invokeLater {
                    if (actualContent != null) {
                        contentPanel.removeAll()
                        contentPanel.add(actualContent, BorderLayout.CENTER)
                        contentPanel.revalidate()
                        contentPanel.repaint()
                        contentInitialized = true
                    }
                }
            }
        }
    }
    
    /**
     * 初始化实际内容
     */
    private fun initializeContent(): JComponent? {
        try {
            // 执行耗时的初始化操作
            // ...
            
            val actualContent = JPanel(BorderLayout())
            // 设置实际内容...
            return actualContent
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").error("Failed to initialize tool window content", e)
            return null
        }
    }
    
    override fun isReadyToClose(): Boolean {
        return true
    }
    
    override fun dispose() {
        // 清理资源
    }
}
```

## 8. 性能监控

### 8.1 性能监控服务

```kotlin
class OmniSharpPerformanceMonitor(project: Project) {
    private val project = project
    private val performanceMetrics = ConcurrentHashMap<String, PerformanceMetric>()
    private val recordingTasks = ConcurrentHashMap<String, Long>()
    private val performanceLogFile: File
    
    init {
        // 创建性能日志文件
        performanceLogFile = File(project.basePath + "/.omnisharp/performance.log")
        performanceLogFile.parentFile.mkdirs()
    }
    
    /**
     * 开始记录任务执行时间
     */
    fun startTask(taskName: String) {
        recordingTasks[taskName] = System.currentTimeMillis()
    }
    
    /**
     * 结束记录任务执行时间
     */
    fun endTask(taskName: String): Long {
        val startTime = recordingTasks.remove(taskName)
        if (startTime != null) {
            val duration = System.currentTimeMillis() - startTime
            
            // 更新性能指标
            updatePerformanceMetric(taskName, duration)
            
            // 记录到日志
            logPerformance(taskName, duration)
            
            return duration
        }
        
        return -1
    }
    
    /**
     * 更新性能指标
     */
    private fun updatePerformanceMetric(taskName: String, duration: Long) {
        val metric = performanceMetrics.computeIfAbsent(taskName) {
            PerformanceMetric(taskName)
        }
        
        metric.record(duration)
    }
    
    /**
     * 记录性能到日志
     */
    private fun logPerformance(taskName: String, duration: Long) {
        try {
            FileWriter(performanceLogFile, true).use {\ writer ->
                val timestamp = SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(Date())
                writer.write("$timestamp - $taskName: ${duration}ms\n")
            }
        } catch (e: Exception) {
            Logger.getInstance("OmniSharp").warn("Failed to write performance log", e)
        }
    }
    
    /**
     * 获取性能指标
     */
    fun getPerformanceMetrics(): Map<String, PerformanceMetric> {
        return performanceMetrics.toMap()
    }
    
    /**
     * 重置性能指标
     */
    fun resetPerformanceMetrics() {
        performanceMetrics.clear()
    }
    
    /**
     * 检查是否有性能问题
     */
    fun checkForPerformanceIssues(): List<PerformanceIssue> {
        val issues = mutableListOf<PerformanceIssue>()
        
        performanceMetrics.forEach { (taskName, metric) ->
            // 检查平均执行时间是否超过阈值
            if (metric.averageDuration > 1000) { // 1秒
                issues.add(PerformanceIssue(
                    taskName = taskName,
                    issueType = "SlowExecution",
                    severity = "High",
                    description = "Task is taking too long to execute: ${metric.averageDuration}ms average"
                ))
            }
            
            // 检查执行次数是否过多
            if (metric.count > 1000) {
                issues.add(PerformanceIssue(
                    taskName = taskName,
                    issueType = "FrequentExecution",
                    severity = "Medium",
                    description = "Task is executed too frequently: ${metric.count} times"
                ))
            }
        }
        
        return issues
    }
}

// 性能指标类
class PerformanceMetric(val name: String) {
    private var _count = 0L
    private var _totalDuration = 0L
    private var _maxDuration = 0L
    private var _minDuration = Long.MAX_VALUE
    private val lock = ReentrantLock()
    
    /**
     * 记录执行时间
     */
    fun record(duration: Long) {
        lock.lock()
        try {
            _count++
            _totalDuration += duration
            _maxDuration = maxOf(_maxDuration, duration)
            _minDuration = minOf(_minDuration, duration)
        } finally {
            lock.unlock()
        }
    }
    
    /**
     * 获取执行次数
     */
    val count: Long
        get() = _count
    
    /**
     * 获取平均执行时间
     */
    val averageDuration: Double
        get() = if (_count > 0) _totalDuration.toDouble() / _count else 0.0
    
    /**
     * 获取最大执行时间
     */
    val maxDuration: Long
        get() = _maxDuration
    
    /**
     * 获取最小执行时间
     */
    val minDuration: Long
        get() = if (_minDuration == Long.MAX_VALUE) 0 else _minDuration
    
    /**
     * 获取总执行时间
     */
    val totalDuration: Long
        get() = _totalDuration
}

// 性能问题类
data class PerformanceIssue(
    val taskName: String,
    val issueType: String,
    val severity: String,
    val description: String
)
```

### 8.2 性能监控 UI

```kotlin
class OmniSharpPerformanceMonitoringToolWindowFactory : ToolWindowFactory {
    override fun createToolWindowContent(project: Project, toolWindow: ToolWindow) {
        val content = OmniSharpPerformanceMonitoringToolWindowContent(project)
        toolWindow.contentManager.addContent(content)
    }
}

class OmniSharpPerformanceMonitoringToolWindowContent(project: Project) : ToolWindowContent(project) {
    private val performanceMonitor = project.getService(OmniSharpPerformanceMonitor::class.java)
    private val contentPanel = JPanel(BorderLayout())
    private val metricsTable = JTable(PerformanceMetricsTableModel())
    private val issuesTable = JTable(PerformanceIssuesTableModel())
    private val tabbedPane = JTabbedPane()
    
    init {
        initUI()
        component = contentPanel
        
        // 定期更新表格
        scheduleUpdates()
    }
    
    private fun initUI() {
        // 设置表格列宽
        metricsTable.columnModel.getColumn(0).preferredWidth = 200 // 任务名称
        metricsTable.columnModel.getColumn(1).preferredWidth = 100 // 执行次数
        metricsTable.columnModel.getColumn(2).preferredWidth = 100 // 平均时间
        metricsTable.columnModel.getColumn(3).preferredWidth = 100 // 最大时间
        metricsTable.columnModel.getColumn(4).preferredWidth = 100 // 最小时间
        metricsTable.columnModel.getColumn(5).preferredWidth = 100 // 总时间
        
        issuesTable.columnModel.getColumn(0).preferredWidth = 200 // 任务名称
        issuesTable.columnModel.getColumn(1).preferredWidth = 150 // 问题类型
        issuesTable.columnModel.getColumn(2).preferredWidth = 100 // 严重性
        issuesTable.columnModel.getColumn(3).preferredWidth = 400 // 描述
        
        // 创建标签页
        tabbedPane.addTab("Performance Metrics", JScrollPane(metricsTable))
        tabbedPane.addTab("Performance Issues", JScrollPane(issuesTable))
        
        // 创建工具栏
        val toolbar = JToolBar()
        
        val refreshButton = JButton("Refresh")
        refreshButton.addActionListener {
            updateTables()
        }
        toolbar.add(refreshButton)
        
        val resetButton = JButton("Reset Metrics")
        resetButton.addActionListener {
            performanceMonitor.resetPerformanceMetrics()
            updateTables()
        }
        toolbar.add(resetButton)
        
        // 设置内容
        contentPanel.add(toolbar, BorderLayout.NORTH)
        contentPanel.add(tabbedPane, BorderLayout.CENTER)
    }
    
    private fun scheduleUpdates() {
        // 每5秒更新一次表格
        Executors.newScheduledThreadPool(1).scheduleAtFixedRate({
            SwingUtilities.invokeLater {
                updateTables()
            }
        }, 0, 5, TimeUnit.SECONDS)
    }
    
    private fun updateTables() {
        // 更新性能指标表格
        val metricsModel = metricsTable.model as PerformanceMetricsTableModel
        metricsModel.updateMetrics(performanceMonitor.getPerformanceMetrics().values)
        
        // 更新性能问题表格
        val issuesModel = issuesTable.model as PerformanceIssuesTableModel
        issuesModel.updateIssues(performanceMonitor.checkForPerformanceIssues())
        
        // 重绘表格
        metricsTable.revalidate()
        metricsTable.repaint()
        issuesTable.revalidate()
        issuesTable.repaint()
    }
    
    // 性能指标表格模型
    class PerformanceMetricsTableModel : AbstractTableModel() {
        private val columns = arrayOf("Task Name", "Count", "Avg Time (ms)", "Max Time (ms)", "Min Time (ms)", "Total Time (ms)")
        private var metrics = emptyList<PerformanceMetric>()
        
        fun updateMetrics(newMetrics: Collection<PerformanceMetric>) {
            metrics = newMetrics.toList().sortedByDescending { it.averageDuration }
            fireTableDataChanged()
        }
        
        override fun getRowCount(): Int {
            return metrics.size
        }
        
        override fun getColumnCount(): Int {
            return columns.size
        }
        
        override fun getColumnName(column: Int): String {
            return columns[column]
        }
        
        override fun getValueAt(rowIndex: Int, columnIndex: Int): Any {
            val metric = metrics[rowIndex]
            
            return when (columnIndex) {
                0 -> metric.name
                1 -> metric.count
                2 -> String.format("%.2f", metric.averageDuration)
                3 -> metric.maxDuration
                4 -> metric.minDuration
                5 -> metric.totalDuration
                else -> ""
            }
        }
    }
    
    // 性能问题表格模型
    class PerformanceIssuesTableModel : AbstractTableModel() {
        private val columns = arrayOf("Task Name", "Issue Type", "Severity", "Description")
        private var issues = emptyList<PerformanceIssue>()
        
        fun updateIssues(newIssues: List<PerformanceIssue>) {
            issues = newIssues.sortedBy { 
                when (it.severity) {
                    "High" -> 0
                    "Medium" -> 1
                    "Low" -> 2
                    else -> 3
                }
            }
            fireTableDataChanged()
        }
        
        override fun getRowCount(): Int {
            return issues.size
        }
        
        override fun getColumnCount(): Int {
            return columns.size
        }
        
        override fun getColumnName(column: Int): String {
            return columns[column]
        }
        
        override fun getValueAt(rowIndex: Int, columnIndex: Int): Any {
            val issue = issues[rowIndex]
            
            return when (columnIndex) {
                0 -> issue.taskName
                1 -> issue.issueType
                2 -> issue.severity
                3 -> issue.description
                else -> ""
            }
        }
    }
}
```

## 9. 下一步

完成高级功能与性能优化后，可以继续学习以下阶段的内容：

1. **阶段七：故障排除与最佳实践** - 学习如何处理常见问题和实施最佳实践

---

本文档是 OmniSharp-for-Intellij 编辑器功能集成指南的第六阶段，详细介绍了高级功能实现（智能重构、实时协作编辑、高级代码分析）和性能优化策略（缓存策略、并发处理、懒加载、性能监控）。通过本阶段的学习，开发者应该能够实现更高级的编辑器功能，并确保插件的性能和响应性。