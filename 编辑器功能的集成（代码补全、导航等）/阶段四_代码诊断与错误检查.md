# 阶段四：代码诊断与错误检查

## 1. 代码诊断功能概述

代码诊断是开发过程中的重要功能，它能够在编写代码时实时提供错误和警告信息，帮助开发者及早发现和修复问题。OmniSharp-for-Intellij 利用 OmniSharp 服务器提供的诊断功能，在 IntelliJ 平台上集成了全面的代码诊断能力。

### 1.1 诊断功能类型

OmniSharp-for-Intellij 支持以下主要诊断功能：

- **语法错误检查**：检测代码中的语法错误
- **语义错误检查**：检测代码中的逻辑错误和类型错误
- **代码风格警告**：提供代码风格和最佳实践建议
- **潜在问题警告**：识别可能导致运行时错误的代码模式
- **实时诊断更新**：在编辑过程中动态更新诊断结果
- **诊断配置**：允许用户自定义诊断规则和级别

## 2. 核心接口与实现

### 2.1 诊断相关接口

OmniSharp-for-Intellij 实现了 IntelliJ 平台的诊断相关接口：

```kotlin
// 问题提供者接口
class OmniSharpProblemProvider : ProblemsProvider {
    override fun collectProblems(
        file: PsiFile,
        sink: ProblemSink
    ) {
        // 实现收集问题的逻辑
    }
}

// 检查器接口
class OmniSharpCodeInspection : LocalInspectionTool() {
    override fun checkFile(
        file: PsiFile,
        manager: InspectionManager,
        isOnTheFly: Boolean
    ): Array<ProblemDescriptor>? {
        // 实现文件检查的逻辑
        return null
    }
}

// 文档标记提供者
class OmniSharpHighlightInfoProvider : HighlightInfoProvider {
    override fun getHighlightInfo(highlightInfo: HighlightInfo, file: PsiFile): HighlightInfo? {
        // 自定义高亮信息
        return highlightInfo
    }
}
```

### 2.2 OmniSharpDiagnosticsService

`OmniSharpDiagnosticsService` 是代码诊断功能的核心服务类，负责与 OmniSharp 服务器通信并处理诊断请求：

```kotlin
class OmniSharpDiagnosticsService(project: Project) : Disposable {
    private val communicator: OmniSharpCommunicator = project.getService(OmniSharpCommunicator::class.java)
    private val diagnosticsCache: DiagnosticsCache = DiagnosticsCache()
    private val virtualFileManager: VirtualFileManager = VirtualFileManager.getInstance()
    
    // 诊断结果监听器
    private val diagnosticListeners = ConcurrentHashMap<VirtualFile, MutableList<DiagnosticListener>>()
    
    /**
     * 获取文件的诊断结果
     * @param file 需要诊断的文件
     * @return 诊断结果列表
     */
    fun getDiagnostics(file: VirtualFile): Mono<List<Diagnostic>> {
        // 检查缓存
        val cachedResult = diagnosticsCache.getDiagnostics(file.path)
        if (cachedResult != null) {
            return Mono.just(cachedResult)
        }
        
        // 构建请求
        val request = GetDiagnosticsRequest(file)
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                // 处理响应，转换为 Diagnostic 对象
                val diagnostics = response.diagnostics.map { it.toDiagnostic(project) }
                // 更新缓存
                diagnosticsCache.putDiagnostics(file.path, diagnostics)
                diagnostics
            }
            .onErrorResume { Mono.empty() }
    }
    
    /**
     * 触发文件的诊断更新
     * @param file 需要更新诊断的文件
     */
    fun updateDiagnostics(file: VirtualFile): CompletableFuture<List<Diagnostic>> {
        // 清除缓存
        diagnosticsCache.removeDiagnostics(file.path)
        
        return getDiagnostics(file)
            .doOnSuccess { diagnostics ->
                // 通知监听器
                notifyDiagnosticsUpdated(file, diagnostics)
            }
            .toFuture()
    }
    
    /**
     * 添加诊断监听器
     * @param file 监听的文件
     * @param listener 监听器
     */
    fun addDiagnosticListener(file: VirtualFile, listener: DiagnosticListener) {
        diagnosticListeners.computeIfAbsent(file) { mutableListOf() }.add(listener)
    }
    
    /**
     * 移除诊断监听器
     * @param file 监听的文件
     * @param listener 监听器
     */
    fun removeDiagnosticListener(file: VirtualFile, listener: DiagnosticListener) {
        diagnosticListeners[file]?.remove(listener)
    }
    
    /**
     * 通知诊断更新
     */
    private fun notifyDiagnosticsUpdated(file: VirtualFile, diagnostics: List<Diagnostic>) {
        diagnosticListeners[file]?.forEach { listener ->
            listener.onDiagnosticsUpdated(file, diagnostics)
        }
    }
    
    override fun dispose() {
        diagnosticsCache.clear()
        diagnosticListeners.clear()
    }
}

// 诊断监听器接口
interface DiagnosticListener {
    fun onDiagnosticsUpdated(file: VirtualFile, diagnostics: List<Diagnostic>)
}
```

## 3. 实时诊断实现

### 3.1 文档监听与诊断触发

```kotlin
class OmniSharpDocumentListener : FileDocumentManagerListener {
    override fun beforeDocumentSaving(document: Document) {
        // 文档保存前触发诊断
        val file = FileDocumentManager.getInstance().getFile(document)
        if (file != null && isSupportedFileType(file)) {
            triggerDiagnostics(file)
        }
    }
    
    override fun fileContentReloaded(file: VirtualFile, document: Document) {
        // 文件内容重新加载后触发诊断
        if (isSupportedFileType(file)) {
            triggerDiagnostics(file)
        }
    }
    
    private fun isSupportedFileType(file: VirtualFile): Boolean {
        return file.extension == "cs"
    }
    
    private fun triggerDiagnostics(file: VirtualFile) {
        val project = ProjectUtil.getProjectForFile(file)
        if (project != null) {
            val diagnosticsService = project.getService(OmniSharpDiagnosticsService::class.java)
            diagnosticsService.updateDiagnostics(file)
        }
    }
}

class OmniSharpEditorDocumentListener(val project: Project, val file: VirtualFile) : DocumentListener {
    private val diagnosticsService = project.getService(OmniSharpDiagnosticsService::class.java)
    private var lastDiagnosticUpdateTime = 0L
    private val DEBOUNCE_TIME_MS = 500 // 防抖时间
    
    override fun documentChanged(event: DocumentEvent) {
        // 使用防抖机制减少诊断请求频率
        val currentTime = System.currentTimeMillis()
        if (currentTime - lastDiagnosticUpdateTime >= DEBOUNCE_TIME_MS) {
            lastDiagnosticUpdateTime = currentTime
            ApplicationManager.getApplication().invokeLater({
                diagnosticsService.updateDiagnostics(file)
            }, ModalityState.any())
        }
    }
}
```

### 3.2 编辑器标记与高亮

```kotlin
class OmniSharpEditorMarkupManager(val project: Project) : DiagnosticListener {
    private val editorMarkupMap = ConcurrentHashMap<VirtualFile, EditorMarkup>()
    
    override fun onDiagnosticsUpdated(file: VirtualFile, diagnostics: List<Diagnostic>) {
        // 更新编辑器标记
        updateEditorMarkup(file, diagnostics)
    }
    
    private fun updateEditorMarkup(file: VirtualFile, diagnostics: List<Diagnostic>) {
        ApplicationManager.getApplication().invokeLater({
            // 获取所有打开的编辑器
            val editors = FileEditorManager.getInstance(project).getAllEditors(file)
            
            editors.forEach { editor ->
                if (editor is TextEditor) {
                    val textEditor = editor
                    val document = textEditor.editor.document
                    val markupModel = textEditor.editor.markupModel
                    
                    // 清除现有的标记
                    editorMarkupMap[file]?.dispose()
                    
                    // 创建新的标记
                    val newEditorMarkup = EditorMarkup()
                    
                    diagnostics.forEach { diagnostic ->
                        val startOffset = document.getLineStartOffset(diagnostic.position.line)
                        val endOffset = min(
                            document.getLineEndOffset(diagnostic.position.line),
                            startOffset + diagnostic.position.column + diagnostic.length
                        )
                        
                        // 创建问题标记
                        val rangeHighlighter = markupModel.addRangeHighlighter(
                            startOffset,
                            endOffset,
                            HighlighterLayer.WARNING,
                            getTextAttributesKey(diagnostic.severity),
                            HighlighterTargetArea.EXACT_RANGE
                        )
                        
                        // 设置工具提示
                        rangeHighlighter.toolTip = diagnostic.message
                        
                        // 添加到标记管理
                        newEditorMarkup.addHighlighter(rangeHighlighter)
                        
                        // 添加到行标记（侧边栏）
                        val gutterIconRenderer = DiagnosticGutterIconRenderer(diagnostic)
                        val gutterHighlighter = markupModel.addLineHighlighter(
                            diagnostic.position.line,
                            HighlighterLayer.WARNING,
                            gutterIconRenderer
                        )
                        newEditorMarkup.addHighlighter(gutterHighlighter)
                    }
                    
                    editorMarkupMap[file] = newEditorMarkup
                }
            }
        })
    }
    
    private fun getTextAttributesKey(severity: DiagnosticSeverity): TextAttributesKey {
        return when (severity) {
            DiagnosticSeverity.ERROR -> HighlighterColors.ERROR
            DiagnosticSeverity.WARNING -> HighlighterColors.WARNING
            DiagnosticSeverity.INFORMATION -> HighlighterColors.INFORMATION
            else -> HighlighterColors.WEAK_WARNING
        }
    }
    
    // 标记管理类
    private class EditorMarkup {
        private val highlighters = mutableListOf<RangeHighlighter>()
        
        fun addHighlighter(highlighter: RangeHighlighter) {
            highlighters.add(highlighter)
        }
        
        fun dispose() {
            highlighters.forEach { it.dispose() }
        }
    }
    
    // 侧边栏图标渲染器
    private class DiagnosticGutterIconRenderer(val diagnostic: Diagnostic) : GutterIconRenderer() {
        override fun getIcon(): Icon {
            return when (diagnostic.severity) {
                DiagnosticSeverity.ERROR -> AllIcons.General.Error
                DiagnosticSeverity.WARNING -> AllIcons.General.Warning
                DiagnosticSeverity.INFORMATION -> AllIcons.General.Information
                else -> AllIcons.General.GutterBall
            }
        }
        
        override fun getTooltipText(): String {
            return diagnostic.message
        }
        
        override fun getClickAction(): AnAction? {
            return null // 可以添加点击操作
        }
    }
    
    fun dispose() {
        editorMarkupMap.values.forEach { it.dispose() }
        editorMarkupMap.clear()
    }
}
```

### 3.3 问题视图集成

```kotlin
class OmniSharpProblemManager(val project: Project) : DiagnosticListener {
    private val problemsView = ProblemsView.SERVICE.getInstance(project)
    
    override fun onDiagnosticsUpdated(file: VirtualFile, diagnostics: List<Diagnostic>) {
        // 更新问题视图
        updateProblemsView(file, diagnostics)
    }
    
    private fun updateProblemsView(file: VirtualFile, diagnostics: List<Diagnostic>) {
        ApplicationManager.getApplication().invokeLater({
            // 创建问题描述符
            val descriptors = diagnostics.mapNotNull { diagnostic ->
                createProblemDescriptor(file, diagnostic)
            }
            
            // 更新问题视图
            problemsView.updateProblems(descriptors, "OmniSharp")
        })
    }
    
    private fun createProblemDescriptor(file: VirtualFile, diagnostic: Diagnostic): ProblemDescriptor? {
        val psiFile = PsiManager.getInstance(project).findFile(file)
        if (psiFile == null) return null
        
        val document = FileDocumentManager.getInstance().getDocument(file)
        if (document == null) return null
        
        val startOffset = document.getLineStartOffset(diagnostic.position.line)
        val endOffset = min(
            document.getLineEndOffset(diagnostic.position.line),
            startOffset + diagnostic.position.column + diagnostic.length
        )
        
        val startElement = psiFile.findElementAt(startOffset)
        val endElement = psiFile.findElementAt(endOffset - 1)
        
        if (startElement == null || endElement == null) return null
        
        // 创建问题描述符
        val severity = when (diagnostic.severity) {
            DiagnosticSeverity.ERROR -> ProblemHighlightType.GENERIC_ERROR
            DiagnosticSeverity.WARNING -> ProblemHighlightType.GENERIC_ERROR_OR_WARNING
            else -> ProblemHighlightType.INFORMATION
        }
        
        return ProblemDescriptorBase(
            startElement,
            endElement,
            diagnostic.message,
            severity,
            false,
            null
        )
    }
}
```

## 4. 诊断级别与过滤

### 4.1 诊断级别配置

```kotlin
class OmniSharpDiagnosticsConfig(project: Project) {
    private val propertiesComponent = PropertiesComponent.getInstance(project)
    
    // 诊断级别枚举
    enum class DiagnosticLevel {
        ERROR,
        WARNING,
        INFORMATION,
        HINT
    }
    
    // 获取当前诊断级别
    fun getCurrentLevel(): DiagnosticLevel {
        val levelName = propertiesComponent.getValue("omniSharp.diagnostics.level", "WARNING")
        return try {
            DiagnosticLevel.valueOf(levelName)
        } catch (e: IllegalArgumentException) {
            DiagnosticLevel.WARNING
        }
    }
    
    // 设置诊断级别
    fun setCurrentLevel(level: DiagnosticLevel) {
        propertiesComponent.setValue("omniSharp.diagnostics.level", level.name)
    }
    
    // 判断诊断是否应该显示
    fun shouldShowDiagnostic(diagnostic: Diagnostic): Boolean {
        val currentLevel = getCurrentLevel()
        val diagnosticLevel = when (diagnostic.severity) {
            DiagnosticSeverity.ERROR -> DiagnosticLevel.ERROR
            DiagnosticSeverity.WARNING -> DiagnosticLevel.WARNING
            DiagnosticSeverity.INFORMATION -> DiagnosticLevel.INFORMATION
            else -> DiagnosticLevel.HINT
        }
        
        return diagnosticLevel.ordinal >= currentLevel.ordinal
    }
    
    // 获取禁用的诊断规则
    fun getDisabledDiagnosticIds(): Set<String> {
        val disabledIds = propertiesComponent.getValue("omniSharp.diagnostics.disabledIds", "")
        return if (disabledIds.isNotEmpty()) {
            disabledIds.split(',').map { it.trim() }.toSet()
        } else {
            emptySet()
        }
    }
    
    // 添加禁用的诊断规则
    fun addDisabledDiagnosticId(id: String) {
        val disabledIds = getDisabledDiagnosticIds().toMutableSet()
        disabledIds.add(id)
        propertiesComponent.setValue("omniSharp.diagnostics.disabledIds", disabledIds.joinToString(","))
    }
    
    // 移除禁用的诊断规则
    fun removeDisabledDiagnosticId(id: String) {
        val disabledIds = getDisabledDiagnosticIds().toMutableSet()
        disabledIds.remove(id)
        propertiesComponent.setValue("omniSharp.diagnostics.disabledIds", disabledIds.joinToString(","))
    }
    
    // 判断诊断规则是否被禁用
    fun isDiagnosticDisabled(id: String): Boolean {
        return getDisabledDiagnosticIds().contains(id)
    }
}
```

### 4.2 诊断过滤

```kotlin
class OmniSharpDiagnosticsFilter(val config: OmniSharpDiagnosticsConfig) {
    /**
     * 过滤诊断结果
     * @param diagnostics 原始诊断结果列表
     * @return 过滤后的诊断结果列表
     */
    fun filterDiagnostics(diagnostics: List<Diagnostic>): List<Diagnostic> {
        return diagnostics.filter { diagnostic ->
            // 检查级别和禁用状态
            !config.isDiagnosticDisabled(diagnostic.id) && config.shouldShowDiagnostic(diagnostic)
        }
    }
    
    /**
     * 根据类别过滤诊断结果
     * @param diagnostics 诊断结果列表
     * @param categories 需要包含的类别列表
     * @return 过滤后的诊断结果列表
     */
    fun filterByCategories(diagnostics: List<Diagnostic>, categories: List<String>): List<Diagnostic> {
        return diagnostics.filter { diagnostic ->
            diagnostic.category in categories
        }
    }
    
    /**
     * 根据文件路径过滤诊断结果
     * @param diagnostics 诊断结果列表
     * @param filePath 文件路径
     * @return 过滤后的诊断结果列表
     */
    fun filterByFilePath(diagnostics: List<Diagnostic>, filePath: String): List<Diagnostic> {
        return diagnostics.filter { diagnostic ->
            diagnostic.filePath == filePath
        }
    }
}
```

## 5. 自定义诊断规则

### 5.1 诊断规则提供者

```kotlin
interface DiagnosticRuleProvider {
    /**
     * 获取所有可用的诊断规则
     */
    fun getAvailableRules(): List<DiagnosticRule>
    
    /**
     * 根据ID获取诊断规则
     */
    fun getRuleById(id: String): DiagnosticRule?
}

class OmniSharpDiagnosticRuleProvider : DiagnosticRuleProvider {
    private val rulesCache = ConcurrentHashMap<String, DiagnosticRule>()
    
    override fun getAvailableRules(): List<DiagnosticRule> {
        // 如果缓存为空，从OmniSharp服务器获取规则
        if (rulesCache.isEmpty()) {
            // 这里应该实现从服务器获取规则的逻辑
            // 为了演示，这里返回一些示例规则
            loadSampleRules()
        }
        
        return rulesCache.values.toList()
    }
    
    override fun getRuleById(id: String): DiagnosticRule? {
        return rulesCache[id]
    }
    
    private fun loadSampleRules() {
        // 添加一些示例规则
        addRule(
            id = "CS0103",
            title = "The name 'name' does not exist in the current context",
            category = "Syntax",
            defaultSeverity = DiagnosticSeverity.ERROR,
            description = "This error occurs when you try to use a name that does not exist in the current context."
        )
        
        addRule(
            id = "CS0219",
            title = "The variable 'variable' is assigned but its value is never used",
            category = "Style",
            defaultSeverity = DiagnosticSeverity.WARNING,
            description = "This warning indicates that a variable is declared and assigned a value, but the value is never used."
        )
        
        addRule(
            id = "CS0618",
            title = "'member' is obsolete",
            category = "Deprecation",
            defaultSeverity = DiagnosticSeverity.WARNING,
            description = "This warning indicates that you are using a member that has been marked as obsolete."
        )
    }
    
    private fun addRule(
        id: String,
        title: String,
        category: String,
        defaultSeverity: DiagnosticSeverity,
        description: String
    ) {
        rulesCache[id] = DiagnosticRule(id, title, category, defaultSeverity, description)
    }
}

// 诊断规则类
class DiagnosticRule(
    val id: String,
    val title: String,
    val category: String,
    val defaultSeverity: DiagnosticSeverity,
    val description: String
)
```

### 5.2 自定义诊断规则配置UI

```kotlin
class OmniSharpDiagnosticsConfigurable : SearchableConfigurable {
    private val rulesPanel = JPanel(GridBagLayout())
    private val ruleProvider = OmniSharpDiagnosticRuleProvider()
    private val config: OmniSharpDiagnosticsConfig
    
    constructor(project: Project) {
        this.config = OmniSharpDiagnosticsConfig(project)
    }
    
    override fun getId(): String = "omniSharp.diagnostics"
    
    override fun getDisplayName(): String = "Diagnostics"
    
    override fun createComponent(): JComponent {
        val panel = JPanel(BorderLayout())
        
        // 添加诊断级别选择
        val levelPanel = createLevelPanel()
        
        // 添加规则过滤面板
        createRulesPanel()
        
        panel.add(levelPanel, BorderLayout.NORTH)
        panel.add(JScrollPane(rulesPanel), BorderLayout.CENTER)
        
        return panel
    }
    
    private fun createLevelPanel(): JPanel {
        val panel = JPanel(FlowLayout(FlowLayout.LEFT))
        panel.border = BorderFactory.createTitledBorder("Diagnostic Level")
        
        val comboBox = JComboBox(OmniSharpDiagnosticsConfig.DiagnosticLevel.values())
        comboBox.selectedItem = config.getCurrentLevel()
        comboBox.addActionListener { 
            val selectedLevel = comboBox.selectedItem as OmniSharpDiagnosticsConfig.DiagnosticLevel
            config.setCurrentLevel(selectedLevel)
        }
        
        panel.add(JLabel("Show diagnostics from level: "))
        panel.add(comboBox)
        
        return panel
    }
    
    private fun createRulesPanel() {
        val constraints = GridBagConstraints()
        constraints.fill = GridBagConstraints.HORIZONTAL
        constraints.weightx = 1.0
        constraints.insets = Insets(5, 5, 5, 5)
        
        // 添加表头
        constraints.gridy = 0
        addColumn(constraints, "ID", 0.1)
        addColumn(constraints, "Title", 0.4)
        addColumn(constraints, "Category", 0.15)
        addColumn(constraints, "Severity", 0.15)
        addColumn(constraints, "Enabled", 0.1)
        
        // 添加规则
        val rules = ruleProvider.getAvailableRules()
        rules.forEachIndexed { index, rule ->
            constraints.gridy = index + 1
            addRuleRow(constraints, rule)
        }
    }
    
    private fun addColumn(constraints: GridBagConstraints, text: String, weightx: Double) {
        val label = JLabel(text)
        label.font = label.font.deriveFont(Font.BOLD)
        constraints.weightx = weightx
        rulesPanel.add(label, constraints)
    }
    
    private fun addRuleRow(constraints: GridBagConstraints, rule: DiagnosticRule) {
        val disabled = config.isDiagnosticDisabled(rule.id)
        
        // ID
        constraints.weightx = 0.1
        rulesPanel.add(JLabel(rule.id), constraints)
        
        // Title
        constraints.weightx = 0.4
        rulesPanel.add(JLabel(rule.title), constraints)
        
        // Category
        constraints.weightx = 0.15
        rulesPanel.add(JLabel(rule.category), constraints)
        
        // Severity
        constraints.weightx = 0.15
        rulesPanel.add(JLabel(rule.defaultSeverity.name), constraints)
        
        // Enabled
        constraints.weightx = 0.1
        val checkBox = JCheckBox()
        checkBox.isSelected = !disabled
        checkBox.addActionListener {
            if (checkBox.isSelected) {
                config.removeDisabledDiagnosticId(rule.id)
            } else {
                config.addDisabledDiagnosticId(rule.id)
            }
        }
        rulesPanel.add(checkBox, constraints)
    }
    
    // 其他必要的方法实现
    override fun isModified(): Boolean {
        return false // 根据实际情况实现
    }
    
    override fun apply() {
        // 应用更改
    }
}
```

## 6. 性能优化

### 6.1 诊断缓存

```kotlin
class DiagnosticsCache {
    private val diagnosticsMap = ConcurrentHashMap<String, List<Diagnostic>>()
    private val fileVersionMap = ConcurrentHashMap<String, Long>()
    private val MAX_CACHE_SIZE = 100
    
    /**
     * 获取文件的诊断结果
     */
    fun getDiagnostics(filePath: String): List<Diagnostic>? {
        return diagnosticsMap[filePath]
    }
    
    /**
     * 存储文件的诊断结果
     */
    fun putDiagnostics(filePath: String, diagnostics: List<Diagnostic>) {
        manageCacheSize()
        diagnosticsMap[filePath] = diagnostics
    }
    
    /**
     * 移除文件的诊断结果
     */
    fun removeDiagnostics(filePath: String) {
        diagnosticsMap.remove(filePath)
        fileVersionMap.remove(filePath)
    }
    
    /**
     * 更新文件版本
     */
    fun updateFileVersion(file: VirtualFile) {
        fileVersionMap[file.path] = file.modificationStamp
    }
    
    /**
     * 检查文件是否需要重新诊断
     */
    fun needsReDiagnosis(file: VirtualFile): Boolean {
        val storedVersion = fileVersionMap[file.path]
        return storedVersion == null || storedVersion != file.modificationStamp
    }
    
    /**
     * 管理缓存大小
     */
    private fun manageCacheSize() {
        if (diagnosticsMap.size > MAX_CACHE_SIZE) {
            // 移除最旧的项
            val oldestKey = diagnosticsMap.keys.firstOrNull()
            oldestKey?.let { 
                diagnosticsMap.remove(it)
                fileVersionMap.remove(it)
            }
        }
    }
    
    /**
     * 清除缓存
     */
    fun clear() {
        diagnosticsMap.clear()
        fileVersionMap.clear()
    }
}
```

### 6.2 增量诊断

```kotlin
class OmniSharpIncrementalDiagnosticsProcessor(val project: Project) {
    private val diagnosticsService = project.getService(OmniSharpDiagnosticsService::class.java)
    private val changeTracker = FileChangeTracker()
    
    /**
     * 处理文件变更并执行增量诊断
     */
    fun processFileChange(file: VirtualFile, changes: List<TextRange>) {
        // 记录变更范围
        changeTracker.recordChanges(file, changes)
        
        // 检查是否需要执行诊断
        if (shouldPerformDiagnostics(file)) {
            // 执行增量诊断
            performIncrementalDiagnostics(file, changes)
        }
    }
    
    /**
     * 判断是否需要执行诊断
     */
    private fun shouldPerformDiagnostics(file: VirtualFile): Boolean {
        // 检查变更范围和频率
        val recentChanges = changeTracker.getRecentChanges(file, 5000) // 最近5秒的变更
        return recentChanges.isNotEmpty()
    }
    
    /**
     * 执行增量诊断
     */
    private fun performIncrementalDiagnostics(file: VirtualFile, changes: List<TextRange>) {
        // 构建增量诊断请求
        val request = IncrementalDiagnosticsRequest(file, changes)
        
        // 发送请求到 OmniSharp 服务器
        val communicator = project.getService(OmniSharpCommunicator::class.java)
        communicator.sendRequest(request)
            .map { response ->
                // 处理响应
                response.diagnostics.map { it.toDiagnostic(project) }
            }
            .subscribe(
                { diagnostics ->
                    // 更新诊断
                    diagnosticsService.updateDiagnostics(file)
                    // 清除变更记录
                    changeTracker.clearChanges(file)
                },
                { error ->
                    // 处理错误
                    Logger.getInstance("OmniSharp").error("Error performing incremental diagnostics", error)
                }
            )
    }
}

class FileChangeTracker {
    private val changeHistory = ConcurrentHashMap<String, MutableList<ChangeRecord>>()
    
    /**
     * 记录文件变更
     */
    fun recordChanges(file: VirtualFile, changes: List<TextRange>) {
        val changeRecords = changes.map { ChangeRecord(System.currentTimeMillis(), it) }
        changeHistory.computeIfAbsent(file.path) { mutableListOf() }.addAll(changeRecords)
    }
    
    /**
     * 获取最近的变更
     */
    fun getRecentChanges(file: VirtualFile, timeWindowMs: Long): List<ChangeRecord> {
        val fileChanges = changeHistory[file.path] ?: return emptyList()
        val currentTime = System.currentTimeMillis()
        return fileChanges.filter { currentTime - it.timestamp <= timeWindowMs }
    }
    
    /**
     * 清除文件变更记录
     */
    fun clearChanges(file: VirtualFile) {
        changeHistory.remove(file.path)
    }
    
    /**
     * 变更记录类
     */
    data class ChangeRecord(val timestamp: Long, val range: TextRange)
}
```

## 7. 诊断功能配置

### 7.1 插件配置注册

```xml
<!-- 在 plugin.xml 中注册配置 -->
<extensions defaultExtensionNs="com.intellij">
  <projectConfigurable 
      instance="com.github.a793181018.omnisharpforintellij.config.OmniSharpDiagnosticsConfigurable" 
      id="omniSharp.diagnostics" 
      displayName="OmniSharp Diagnostics" 
  />
  
  <problemsProvider implementation="com.github.a793181018.omnisharpforintellij.diagnostics.OmniSharpProblemProvider" />
  
  <inspectionToolProvider implementation="com.github.a793181018.omnisharpforintellij.diagnostics.OmniSharpInspectionToolProvider" />
  
  <fileDocumentManagerListener implementation="com.github.a793181018.omnisharpforintellij.diagnostics.OmniSharpDocumentListener" />
</extensions>
```

### 7.2 快捷键配置

```xml
<!-- 在 plugin.xml 中配置快捷键 -->
<keymap>
  <action id="OmniSharp.NextError" text="Next Error">
    <keyboard-shortcut first-keystroke="f2" keymap="$default" />
  </action>
  <action id="OmniSharp.PreviousError" text="Previous Error">
    <keyboard-shortcut first-keystroke="shift f2" keymap="$default" />
  </action>
  <action id="OmniSharp.InspectCode" text="Inspect Code">
    <keyboard-shortcut first-keystroke="alt shift i" keymap="$default" />
  </action>
</keymap>
```

## 8. 常见问题与解决方案

### 8.1 诊断不显示或不准确

**问题症状**：编辑器中不显示错误或警告，或者显示的错误不准确。

**可能原因**：
- OmniSharp 服务器未启动或已崩溃
- 缓存过期
- 诊断级别设置过高
- 诊断规则被禁用

**解决方案**：
1. 检查 OmniSharp 服务器状态
2. 清除缓存（File | Invalidate Caches / Restart）
3. 降低诊断级别设置
4. 检查诊断规则启用状态

### 8.2 诊断更新不及时

**问题症状**：修改代码后，诊断结果没有立即更新。

**可能原因**：
- 防抖时间设置过长
- 服务器响应慢
- 增量诊断未正确配置

**解决方案**：
1. 减少防抖时间
2. 优化服务器性能
3. 检查增量诊断配置
4. 手动触发诊断更新

### 8.3 诊断性能问题

**问题症状**：诊断导致编辑器卡顿或响应缓慢。

**可能原因**：
- 诊断请求过于频繁
- 大型项目导致诊断结果过多
- 服务器性能问题

**解决方案**：
1. 增加防抖时间
2. 提高诊断级别过滤更多诊断
3. 禁用不常用的诊断规则
4. 优化服务器性能
5. 增加缓存大小

## 9. 下一步

完成代码诊断与错误检查功能集成后，可以继续学习以下阶段的内容：

1. **阶段五：代码格式化与风格管理** - 学习如何实现代码格式化功能
2. **阶段六：高级功能与性能优化** - 学习如何实现高级功能和性能优化
3. **阶段七：故障排除与最佳实践** - 学习如何处理常见问题和实施最佳实践

---

本文档是 OmniSharp-for-Intellij 编辑器功能集成指南的第四阶段，详细介绍了代码诊断与错误检查功能的实现原理、核心接口、实时诊断、诊断级别配置、自定义诊断规则和性能优化策略。通过本阶段的学习，开发者应该能够理解和实现高质量的代码诊断功能。