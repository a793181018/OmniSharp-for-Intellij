# 阶段二：代码补全功能集成

## 1. 代码补全功能概述

代码补全是 OmniSharp-for-Intellij 插件的核心功能之一，它提供智能的代码建议和自动完成，帮助开发者快速编写代码并减少错误。该功能通过与 OmniSharp 服务器交互，获取上下文相关的补全项，并根据用户输入进行过滤和排序。

### 1.1 补全功能类型

OmniSharp-for-Intellij 支持多种类型的代码补全：

- **基本补全**：提供变量名、方法名、类型名等基本元素的补全
- **智能补全**：基于上下文提供更智能的建议，如成员访问、方法参数等
- **导入补全**：自动导入缺失的命名空间和类型
- **后补全**：在输入某些字符后自动补全代码结构
- **实时模板补全**：支持代码模板的快速插入

## 2. 核心接口与实现

### 2.1 代码补全相关接口

OmniSharp-for-Intellij 实现了 IntelliJ 平台的代码补全相关接口：

```kotlin
// 代码补全提供者接口
class OmniSharpCompletionProvider : CompletionProvider<CompletionParameters>() {
    override fun addCompletions(
        parameters: CompletionParameters,
        context: ProcessingContext,
        resultSet: CompletionResultSet
    ) {
        // 实现代码补全逻辑
    }
}

// 补全贡献者，用于注册补全提供者
class OmniSharpCompletionContributor : CompletionContributor() {
    init {
        extend(CompletionType.BASIC, PlatformPatterns.psiElement(), OmniSharpCompletionProvider())
        extend(CompletionType.SMART, PlatformPatterns.psiElement(), OmniSharpSmartCompletionProvider())
    }
}
```

### 2.2 OmniSharpCompletionService

`OmniSharpCompletionService` 是代码补全功能的核心服务类，负责与 OmniSharp 服务器通信并处理补全结果：

```kotlin
class OmniSharpCompletionService(project: Project) : Disposable {
    private val communicator: OmniSharpCommunicator = project.getService(OmniSharpCommunicator::class.java)
    private val cache: CompletionCache = CompletionCache()
    
    /**
     * 获取代码补全项
     * @param file 当前文件
     * @param offset 光标位置
     * @return 补全项列表
     */
    fun getCompletions(file: VirtualFile, offset: Int): Mono<List<CompletionItem>> {
        // 检查缓存
        val cachedResult = cache.get(file, offset)
        if (cachedResult != null) {
            return Mono.just(cachedResult)
        }
        
        // 构建请求
        val request = CompletionRequest(file, offset)
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                // 处理响应，转换为 IntelliJ 平台的 CompletionItem
                val items = response.items.map { it.toCompletionItem() }
                // 更新缓存
                cache.put(file, offset, items)
                items
            }
            .onErrorResume { Mono.empty() }
    }
    
    override fun dispose() {
        cache.clear()
    }
}
```

## 3. 代码补全实现流程

代码补全功能的实现涉及多个步骤，从用户输入到显示补全列表：

### 3.1 补全触发与请求构建

当用户在编辑器中输入时，IntelliJ 平台会触发补全请求。OmniSharpCompletionProvider 捕获这些请求并构建适当的参数：

```kotlin
override fun addCompletions(
    parameters: CompletionParameters,
    context: ProcessingContext,
    resultSet: CompletionResultSet
) {
    val position = parameters.position
    val file = position.containingFile.originalFile
    val virtualFile = file.virtualFile ?: return
    
    // 检查是否为 C# 文件
    if (virtualFile.extension != "cs") return
    
    val offset = parameters.offset
    val project = parameters.editor.project ?: return
    
    // 获取补全服务
    val completionService = project.getService(OmniSharpCompletionService::class.java)
    
    // 异步获取补全项
    completionService.getCompletions(virtualFile, offset)
        .subscribeOn(Schedulers.boundedElastic())
        .subscribe {
            // 将补全项添加到结果集
            it.forEach { item -> resultSet.addElement(item) }
            resultSet.stopHere()
        }
}
```

### 3.2 与 OmniSharp 服务器通信

补全服务构建请求并通过通信器发送到 OmniSharp 服务器：

```kotlin
class OmniSharpCommunicator(project: Project) {
    // 发送补全请求
    fun sendRequest(request: CompletionRequest): Mono<CompletionResponse> {
        val payload = mapOf(
            "FileName" to request.file.path,
            "Line" to request.line,
            "Column" to request.column,
            "WordToComplete" to request.wordToComplete
        )
        
        return sendRequest("autocomplete", payload)
            .map { response -> parseCompletionResponse(response) }
    }
    
    private fun <T> sendRequest(endpoint: String, payload: Map<String, Any>): Mono<T> {
        // 实现与 OmniSharp 服务器的通信
    }
}
```

### 3.3 处理补全响应

收到服务器响应后，将其转换为 IntelliJ 平台的 CompletionItem 对象：

```kotlin
fun OmniSharpCompletionItem.toCompletionItem(): CompletionItem {
    val item = LookupElementBuilder.create(this.displayText)
        .withIcon(getIconForType(this.kind))
        .withTypeText(this.returnType, true)
        
    // 设置补全项的插入文本
    if (this.insertText != null) {
        item.withInsertHandler {\ context, _ ->
            context.document.replaceString(
                context.startOffset, 
                context.tailOffset, 
                this.insertText
            )
            
            // 处理占位符
            if (this.snippet != null) {
                SnippetManager.getInstance(context.project)
                    .finishText(this.snippet, context.editor, -1)
            }
        }
    }
    
    return item
}
```

## 4. 自定义补全提供者

OmniSharp-for-Intellij 允许创建自定义补全提供者，以扩展默认的补全功能：

### 4.1 创建自定义补全提供者

```kotlin
class CustomCompletionProvider : CompletionProvider<CompletionParameters>() {
    override fun addCompletions(
        parameters: CompletionParameters,
        context: ProcessingContext,
        resultSet: CompletionResultSet
    ) {
        // 检查是否在特定上下文中
        val position = parameters.position
        if (!isInSpecificContext(position)) return
        
        // 添加自定义补全项
        val customItems = generateCustomCompletionItems(position)
        customItems.forEach { resultSet.addElement(it) }
    }
    
    private fun isInSpecificContext(position: PsiElement): Boolean {
        // 判断当前位置是否在特定上下文中
        return true // 实际实现需要更复杂的上下文检查
    }
    
    private fun generateCustomCompletionItems(position: PsiElement): List<CompletionItem> {
        // 生成自定义补全项
        return listOf(
            LookupElementBuilder.create("CustomItem1").withPresentableText("Custom Item 1"),
            LookupElementBuilder.create("CustomItem2").withPresentableText("Custom Item 2")
        )
    }
}
```

### 4.2 注册自定义补全提供者

通过扩展点或在插件初始化时注册自定义补全提供者：

```kotlin
class CustomCompletionContributor : CompletionContributor() {
    init {
        extend(
            CompletionType.BASIC,
            PlatformPatterns.psiElement().withLanguage(CSharpLanguage.INSTANCE),
            CustomCompletionProvider()
        )
    }
}

// 在 plugin.xml 中注册
<!--
<extensions defaultExtensionNs="com.intellij">
  <completion.contributor implementation="com.github.a793181018.omnisharpforintellij.editor.completion.CustomCompletionContributor" />
</extensions>
-->
```

## 5. 补全项过滤与排序

为了提供更准确的补全建议，OmniSharp-for-Intellij 实现了智能的过滤和排序机制：

### 5.1 基于上下文的过滤

```kotlin
class ContextAwareCompletionFilter {
    fun filter(completionItems: List<CompletionItem>, context: CompletionContext): List<CompletionItem> {
        // 基于当前上下文过滤不相关的补全项
        return completionItems.filter { item ->
            when (context) {
                is ExpressionContext -> item.isValidInExpressionContext()
                is StatementContext -> item.isValidInStatementContext()
                // 其他上下文类型
                else -> true
            }
        }
    }
}
```

### 5.2 相关性排序

```kotlin
class CompletionItemSorter {
    fun sort(items: List<CompletionItem>, context: CompletionContext): List<CompletionItem> {
        return items.sortedWith(compareByDescending {
            // 计算相关性分数
            calculateRelevanceScore(it, context)
        })
    }
    
    private fun calculateRelevanceScore(item: CompletionItem, context: CompletionContext): Double {
        var score = 0.0
        
        // 完全匹配加分
        if (item.displayText.equals(context.prefix, ignoreCase = true)) {
            score += 100.0
        }
        
        // 前缀匹配加分
        if (item.displayText.startsWith(context.prefix, ignoreCase = true)) {
            score += 50.0
        }
        
        // 驼峰匹配加分
        if (matchesCamelHump(item.displayText, context.prefix)) {
            score += 30.0
        }
        
        // 类型相关性加分
        score += getTypeRelevanceScore(item, context.expectedType)
        
        return score
    }
}
```

## 6. 性能优化

代码补全功能的性能对用户体验至关重要。OmniSharp-for-Intellij 实现了多种性能优化技术：

### 6.1 智能缓存

```kotlin
class CompletionCache {
    private val cache = ConcurrentHashMap<CacheKey, List<CompletionItem>>()
    private val MAX_CACHE_SIZE = 1000
    
    fun get(file: VirtualFile, offset: Int): List<CompletionItem>? {
        val key = CacheKey(file.path, offset)
        return cache[key]
    }
    
    fun put(file: VirtualFile, offset: Int, items: List<CompletionItem>) {
        // 限制缓存大小
        if (cache.size >= MAX_CACHE_SIZE) {
            // 移除最早添加的项
            val oldestKey = cache.keys.firstOrNull()
            oldestKey?.let { cache.remove(it) }
        }
        
        val key = CacheKey(file.path, offset)
        cache[key] = items
    }
    
    fun clear() {
        cache.clear()
    }
    
    private data class CacheKey(val filePath: String, val offset: Int)
}
```

### 6.2 延迟请求

```kotlin
class DebouncedCompletionRequest {
    private val debounceTime = 100L // 毫秒
    private val pendingRequests = ConcurrentHashMap<RequestKey, CompletableFuture<List<CompletionItem>>>()
    
    fun request(file: VirtualFile, offset: Int, provider: () -> List<CompletionItem>): CompletableFuture<List<CompletionItem>> {
        val key = RequestKey(file.path, offset)
        
        // 取消相同位置的待处理请求
        pendingRequests[key]?.cancel(false)
        
        // 创建新的延迟请求
        val future = CompletableFuture<List<CompletionItem>>()
        pendingRequests[key] = future
        
        ApplicationManager.getApplication().executeOnPooledThread {
            try {
                Thread.sleep(debounceTime)
                
                // 检查请求是否已取消
                if (future.isCancelled) {
                    pendingRequests.remove(key)
                    return@executeOnPooledThread
                }
                
                val result = provider()
                future.complete(result)
            } catch (e: Exception) {
                future.completeExceptionally(e)
            } finally {
                pendingRequests.remove(key)
            }
        }
        
        return future
    }
    
    private data class RequestKey(val filePath: String, val offset: Int)
}
```

### 6.3 增量更新

```kotlin
class IncrementalCompletionUpdater {
    fun updateCompletions(
        editor: Editor,
        newText: String,
        oldCompletions: List<CompletionItem>
    ): List<CompletionItem> {
        // 基于新输入增量更新补全列表，而不是重新获取
        val prefix = extractPrefix(editor, newText)
        
        // 过滤现有补全项
        val filtered = oldCompletions.filter {
            it.lookupString.startsWith(prefix, ignoreCase = true)
        }
        
        // 如果过滤后结果太少，可能需要重新请求
        if (filtered.size < 5) {
            return emptyList() // 触发重新获取
        }
        
        return filtered
    }
}
```

## 7. 代码补全配置

OmniSharp-for-Intellij 提供了多种配置选项，允许用户自定义代码补全行为：

### 7.1 配置界面

```kotlin
class OmniSharpCompletionConfigurable : SearchableConfigurable {
    override fun getId(): String = "omniSharp.completion"
    
    override fun getDisplayName(): String = "Code Completion"
    
    override fun createComponent(): JComponent {
        val panel = JPanel(BorderLayout())
        
        // 启用智能补全
        val enableSmartCompletion = JCheckBox("Enable Smart Completion")
        enableSmartCompletion.isSelected = true
        
        // 启用导入补全
        val enableImportCompletion = JCheckBox("Enable Import Completion")
        enableImportCompletion.isSelected = true
        
        // 补全触发字符
        val triggerCharsPanel = JPanel(FlowLayout(FlowLayout.LEFT))
        triggerCharsPanel.add(JLabel("Trigger characters:"))
        val triggerCharsField = JTextField(".->: ")
        triggerCharsField.columns = 20
        triggerCharsPanel.add(triggerCharsField)
        
        // 布局组件
        val contentPanel = JPanel(GridLayout(0, 1, 0, 10))
        contentPanel.add(enableSmartCompletion)
        contentPanel.add(enableImportCompletion)
        contentPanel.add(triggerCharsPanel)
        
        panel.add(contentPanel, BorderLayout.NORTH)
        return panel
    }
    
    // 其他必要的方法实现
}
```

### 7.2 配置存储

```kotlin
class OmniSharpCompletionSettings : PersistentStateComponent<OmniSharpCompletionSettings.State> {
    class State {
        var enableSmartCompletion: Boolean = true
        var enableImportCompletion: Boolean = true
        var triggerCharacters: String = ".->: "
        var caseSensitive: Boolean = false
    }
    
    private val myState = State()
    
    override fun getState(): State = myState
    
    override fun loadState(state: State) {
        myState.enableSmartCompletion = state.enableSmartCompletion
        myState.enableImportCompletion = state.enableImportCompletion
        myState.triggerCharacters = state.triggerCharacters
        myState.caseSensitive = state.caseSensitive
    }
    
    companion object {
        fun getInstance(project: Project): OmniSharpCompletionSettings {
            return ServiceManager.getService(project, OmniSharpCompletionSettings::class.java)
        }
    }
}
```

## 8. 常见问题与解决方案

### 8.1 补全不工作

**问题症状**：输入时没有显示补全建议。

**可能原因**：
- OmniSharp 服务器未启动
- 项目配置不正确
- 缓存问题

**解决方案**：
1. 检查 OmniSharp 服务器状态（View | Tool Windows | OmniSharp）
2. 重新启动 OmniSharp 服务器
3. 清除缓存（File | Invalidate Caches / Restart）
4. 确保项目文件正确配置

### 8.2 补全速度慢

**问题症状**：显示补全建议需要很长时间。

**可能原因**：
- 大型项目
- 服务器性能问题
- 网络延迟（如果使用远程服务器）

**解决方案**：
1. 增加缓存大小
2. 启用持久化缓存
3. 排除大型生成文件
4. 考虑使用更快的服务器硬件

### 8.3 补全项不准确

**问题症状**：显示的补全项与上下文不相关。

**可能原因**：
- 语法错误导致上下文分析不准确
- 项目符号未正确索引
- 配置问题

**解决方案**：
1. 修复代码中的语法错误
2. 重新索引项目
3. 调整补全过滤和排序设置

## 9. 下一步

完成代码补全功能集成后，可以继续学习以下阶段的内容：

1. **阶段三：代码导航功能集成** - 学习如何实现代码导航相关功能
2. **阶段四：代码诊断与错误检查** - 学习如何实现实时错误检查和警告
3. **阶段五：代码格式化与风格管理** - 学习如何实现代码格式化功能

---

本文档是 OmniSharp-for-Intellij 编辑器功能集成指南的第二阶段，详细介绍了代码补全功能的实现原理、核心接口、优化策略和配置选项。通过本阶段的学习，开发者应该能够理解和实现高质量的代码补全功能。