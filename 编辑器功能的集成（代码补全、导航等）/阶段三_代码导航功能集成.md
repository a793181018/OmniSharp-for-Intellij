# 阶段三：代码导航功能集成

## 1. 代码导航功能概述

代码导航是开发过程中的关键功能，它帮助开发者快速理解和浏览代码库。OmniSharp-for-Intellij 提供了丰富的代码导航功能，包括查找定义、查找引用、类型层次结构、文件结构等，这些功能通过与 OmniSharp 服务器交互实现。

### 1.1 导航功能类型

OmniSharp-for-Intellij 支持以下主要导航功能：

- **查找定义**：快速跳转到符号的定义位置
- **查找引用**：查找符号在项目中的所有引用
- **类型层次结构**：查看类的继承关系和实现关系
- **文件结构**：查看当前文件的结构和成员
- **快速导航**：通过名称快速定位文件或符号
- **相关文件**：在相关文件（如头文件和源文件）之间切换

## 2. 核心接口与实现

### 2.1 导航相关接口

OmniSharp-for-Intellij 实现了 IntelliJ 平台的导航相关接口：

```kotlin
// 定义查找器接口
class OmniSharpGotoDeclarationHandler : GotoDeclarationHandler {
    override fun getGotoDeclarationTargets(
        sourceElement: PsiElement?, 
        offset: Int, 
        editor: Editor?
    ): Array<PsiElement>? {
        // 实现跳转到定义的逻辑
        return null // 实际实现会返回定义位置的 PsiElement 数组
    }
}

// 引用查找器接口
class OmniSharpFindUsagesHandlerFactory : FindUsagesHandlerFactory {
    override fun canFindUsages(element: PsiElement): Boolean {
        // 判断是否可以查找该元素的引用
        return true // 实际实现需要检查元素类型
    }
    
    override fun createFindUsagesHandler(element: PsiElement, forHighlightUsages: Boolean): FindUsagesHandler? {
        // 创建查找引用的处理器
        return OmniSharpFindUsagesHandler(element) // 自定义的处理器
    }
}

// 类型层次结构提供者
class OmniSharpTypeHierarchyProvider : TypeHierarchyProvider {
    override fun getTargetInfo(editor: Editor, file: PsiFile): TypeHierarchyRequestorInfo? {
        // 实现类型层次结构的逻辑
        return null // 实际实现会返回类型层次结构的请求信息
    }
}
```

### 2.2 OmniSharpNavigationService

`OmniSharpNavigationService` 是代码导航功能的核心服务类，负责与 OmniSharp 服务器通信并处理导航请求：

```kotlin
class OmniSharpNavigationService(project: Project) : Disposable {
    private val communicator: OmniSharpCommunicator = project.getService(OmniSharpCommunicator::class.java)
    private val navigationCache: NavigationCache = NavigationCache()
    
    /**
     * 查找符号定义
     * @param file 当前文件
     * @param offset 光标位置
     * @return 定义位置列表
     */
    fun findDefinitions(file: VirtualFile, offset: Int): Mono<List<Location>> {
        // 检查缓存
        val cacheKey = "${file.path}:$offset"
        val cachedResult = navigationCache.getDefinition(cacheKey)
        if (cachedResult != null) {
            return Mono.just(cachedResult)
        }
        
        // 构建请求
        val request = DefinitionRequest(file, offset)
        
        // 发送请求到 OmniSharp 服务器
        return communicator.sendRequest(request)
            .map { response ->
                // 处理响应，转换为 Location 对象
                val locations = response.definitions.map { it.toLocation(project) }
                // 更新缓存
                navigationCache.putDefinition(cacheKey, locations)
                locations
            }
            .onErrorResume { Mono.empty() }
    }
    
    /**
     * 查找符号引用
     * @param file 当前文件
     * @param offset 光标位置
     * @param includeDefinition 是否包含定义
     * @return 引用位置列表
     */
    fun findReferences(
        file: VirtualFile, 
        offset: Int, 
        includeDefinition: Boolean = false
    ): Mono<List<Location>> {
        // 实现查找引用的逻辑
        // 类似 findDefinitions 方法
        return Mono.empty()
    }
    
    /**
     * 获取类型层次结构
     * @param file 当前文件
     * @param offset 光标位置
     * @param hierarchyType 层次结构类型（继承、实现等）
     * @return 类型层次结构信息
     */
    fun getTypeHierarchy(
        file: VirtualFile, 
        offset: Int, 
        hierarchyType: HierarchyType
    ): Mono<TypeHierarchyInfo> {
        // 实现获取类型层次结构的逻辑
        return Mono.empty()
    }
    
    override fun dispose() {
        navigationCache.clear()
    }
}
```

## 3. 查找定义功能实现

### 3.1 定义查找处理器

```kotlin
class OmniSharpGotoDeclarationHandler : GotoDeclarationHandler {
    override fun getGotoDeclarationTargets(
        sourceElement: PsiElement?, 
        offset: Int, 
        editor: Editor?
    ): Array<PsiElement>? {
        if (sourceElement == null || editor == null) return null
        
        val file = sourceElement.containingFile.originalFile
        val virtualFile = file.virtualFile ?: return null
        
        // 检查是否为 C# 文件
        if (virtualFile.extension != "cs") return null
        
        val project = editor.project ?: return null
        
        // 获取导航服务
        val navigationService = project.getService(OmniSharpNavigationService::class.java)
        
        // 同步查找定义（为了 UI 响应性，实际可能需要异步处理）
        val locations = navigationService.findDefinitions(virtualFile, offset)
            .block(Duration.ofSeconds(5)) ?: return null
        
        // 转换为 PsiElement
        return locations.mapNotNull { location ->
            findPsiElementAtLocation(project, location)
        }.toTypedArray()
    }
    
    private fun findPsiElementAtLocation(project: Project, location: Location): PsiElement? {
        val virtualFile = LocalFileSystem.getInstance().findFileByPath(location.filePath)
        if (virtualFile == null) return null
        
        val psiFile = PsiManager.getInstance(project).findFile(virtualFile)
        if (psiFile == null) return null
        
        val position = location.position
        return psiFile.findElementAt(psiFile.getLineStartOffset(position.line) + position.column)
    }
}
```

### 3.2 与 OmniSharp 服务器通信

```kotlin
class OmniSharpCommunicator(project: Project) {
    // 发送查找定义请求
    fun sendRequest(request: DefinitionRequest): Mono<DefinitionResponse> {
        val payload = mapOf(
            "FileName" to request.file.path,
            "Line" to request.line,
            "Column" to request.column
        )
        
        return sendRequest("findsymbols", payload)
            .map { response -> parseDefinitionResponse(response) }
    }
}
```

### 3.3 位置转换与导航

```kotlin
fun OmniSharpDefinition.toLocation(project: Project): Location {
    val filePath = this.fileName
    val line = this.line - 1 // 转换为 0 基索引
    val column = this.column - 1 // 转换为 0 基索引
    
    return Location(filePath, Position(line, column))
}

// 导航到指定位置
fun navigateToLocation(project: Project, location: Location) {
    val virtualFile = LocalFileSystem.getInstance().findFileByPath(location.filePath)
    if (virtualFile == null) {
        Notifications.Bus.notify(
            Notification(
                "OmniSharp",
                "Navigation Error",
                "Cannot find file: ${location.filePath}",
                NotificationType.ERROR
            ),
            project
        )
        return
    }
    
    val position = location.position
    
    // 打开文件并导航到指定位置
    ApplicationManager.getApplication().invokeLater {
        val editor = FileEditorManager.getInstance(project).openTextEditor(
            OpenFileDescriptor(project, virtualFile),
            true
        )
        
        editor?.caretModel?.run {
            val lineStartOffset = editor.document.getLineStartOffset(position.line)
            moveToOffset(lineStartOffset + position.column)
        }
    }
}
```

## 4. 查找引用功能实现

### 4.1 引用查找处理器

```kotlin
class OmniSharpFindUsagesHandlerFactory : FindUsagesHandlerFactory {
    override fun canFindUsages(element: PsiElement): Boolean {
        // 检查元素是否可以查找引用
        return element is PsiIdentifier && element.parent is PsiNamedElement
    }
    
    override fun createFindUsagesHandler(element: PsiElement, forHighlightUsages: Boolean): FindUsagesHandler? {
        return OmniSharpFindUsagesHandler(element)
    }
}

class OmniSharpFindUsagesHandler(element: PsiElement) : FindUsagesHandler(element) {
    override fun findReferencesToHighlight(): Array<PsiReference> {
        // 返回用于高亮显示的引用
        return PsiReference.EMPTY_ARRAY
    }
    
    override fun findUsages(processor: FindUsagesProcessPresentation?): Collection<UsageInfo> {
        val project = myPsiElement.project
        val file = myPsiElement.containingFile.originalFile.virtualFile ?: return emptyList()
        val offset = myPsiElement.textOffset
        
        // 获取导航服务
        val navigationService = project.getService(OmniSharpNavigationService::class.java)
        
        // 查找引用
        val locations = navigationService.findReferences(file, offset)
            .block(Duration.ofSeconds(10)) ?: return emptyList()
        
        // 转换为 UsageInfo
        return locations.mapNotNull { location ->
            val virtualFile = LocalFileSystem.getInstance().findFileByPath(location.filePath)
            if (virtualFile == null) return@mapNotNull null
            
            val psiFile = PsiManager.getInstance(project).findFile(virtualFile)
            if (psiFile == null) return@mapNotNull null
            
            val position = location.position
            val offsetInFile = psiFile.getLineStartOffset(position.line) + position.column
            val element = psiFile.findElementAt(offsetInFile)
            
            if (element != null) {
                UsageInfo(element)
            } else {
                null
            }
        }
    }
}
```

### 4.2 引用结果显示

```kotlin
class OmniSharpUsageViewPresentation : UsageViewPresentation {}

class OmniSharpUsageViewFactory : UsageViewFactory {
    override fun createUsageView(
        usageViewManager: UsageViewManager,
        presentation: UsageViewPresentation,
        searchProcess: FindUsagesProcess,
        usages: Collection<UsageInfo>
    ): UsageView {
        // 创建自定义的引用结果视图
        return UsageViewImpl(usageViewManager.project, presentation, searchProcess, usages)
    }
}
```

## 5. 类型层次结构功能实现

### 5.1 类型层次结构提供者

```kotlin
class OmniSharpTypeHierarchyProvider : TypeHierarchyProvider {
    override fun getTargetInfo(editor: Editor, file: PsiFile): TypeHierarchyRequestorInfo? {
        val offset = editor.caretModel.offset
        val element = file.findElementAt(offset)
        
        // 查找包含光标位置的类型声明
        var typeElement = PsiTreeUtil.getParentOfType(element, PsiClass::class.java)
        if (typeElement == null) {
            // 尝试从表达式或变量中获取类型
            val reference = file.findReferenceAt(offset)
            if (reference != null) {
                val resolve = reference.resolve()
                if (resolve is PsiClass) {
                    typeElement = resolve
                } else if (resolve is PsiMember) {
                    typeElement = resolve.containingClass
                }
            }
        }
        
        if (typeElement == null) return null
        
        return object : TypeHierarchyRequestorInfo {
            override fun getElement(): PsiElement = typeElement!!
            override fun getTypeHierarchyLevel(): TypeHierarchyLevel = 
                TypeHierarchyLevel(TreeToPSIConverter.getClassManager(editor.project).getClassInfo(typeElement!!))
        }
    }
}
```

### 5.2 层次结构视图

```kotlin
class OmniSharpHierarchyBrowser(project: Project, element: PsiElement) : TypeHierarchyBrowser(project, element) {
    override fun getContentDisplayName(typeName: String, isInterface: Boolean, showQualifiedName: Boolean): String {
        // 自定义显示名称
        return if (showQualifiedName) typeName else typeName.substringAfterLast('.')
    }
    
    override fun getQualifiedName(`object`: Any?): String {
        // 获取限定名称
        return super.getQualifiedName(`object`)
    }
}
```

## 6. 文件结构功能实现

### 6.1 文件结构视图工厂

```kotlin
class OmniSharpStructureViewFactory : FileStructureViewFactory {
    override fun getStructureViewBuilder(file: PsiFile): StructureViewBuilder {
        return object : TreeBasedStructureViewBuilder() {
            override fun createStructureViewModel(editor: Editor?): StructureViewModel {
                return OmniSharpStructureViewModel(file, editor)
            }
            
            override fun isRootNodeShown(): Boolean = false
        }
    }
}

class OmniSharpStructureViewModel(file: PsiFile, editor: Editor?) : 
    StructureViewModelBase(file, editor, OmniSharpStructureViewElement(file)),
    StructureViewModel.ElementInfoProvider {
    
    override fun getSuitableClasses(): Array<Class<out PsiElement>> {
        return arrayOf(PsiClass::class.java, PsiMethod::class.java, PsiField::class.java)
    }
    
    override fun isAlwaysShowsPlus(element: StructureViewTreeElement): Boolean = false
    
    override fun isAlwaysLeaf(element: StructureViewTreeElement): Boolean {
        val value = element.value
        return value !is PsiClass && value !is PsiFile
    }
}

class OmniSharpStructureViewElement(private val element: PsiElement) : StructureViewTreeElement {
    override fun getValue(): Any = element
    
    override fun navigate(requestFocus: Boolean) {
        element.navigate(requestFocus)
    }
    
    override fun canNavigate(): Boolean = element.canNavigate()
    
    override fun canNavigateToSource(): Boolean = element.canNavigateToSource()
    
    override fun getPresentation(): ItemPresentation {
        return when (element) {
            is PsiFile -> {
                object : ItemPresentation {
                    override fun getPresentableText(): String = element.name
                    override fun getLocationString(): String? = null
                    override fun getIcon(unused: Boolean): Icon = element.getIcon(0)
                }
            }
            is ItemPresentation -> element
            else -> {
                object : ItemPresentation {
                    override fun getPresentableText(): String = element.text
                    override fun getLocationString(): String? = null
                    override fun getIcon(unused: Boolean): Icon? = null
                }
            }
        }
    }
    
    override fun getChildren(): Array<StructureViewTreeElement> {
        return when (element) {
            is PsiFile -> {
                element.children
                    .filter { it is PsiClass || it is PsiMethod || it is PsiField }
                    .map { OmniSharpStructureViewElement(it) }
                    .toTypedArray()
            }
            is PsiClass -> {
                element.children
                    .filter { it is PsiClass || it is PsiMethod || it is PsiField }
                    .map { OmniSharpStructureViewElement(it) }
                    .toTypedArray()
            }
            else -> StructureViewTreeElement.EMPTY_ARRAY
        }
    }
}
```

## 7. 快速导航功能实现

### 7.1 文件快速导航

```kotlin
class OmniSharpGotoFileProvider : ChooseByNameContributor {
    override fun getNames(project: Project, includeNonProjectItems: Boolean): Array<String> {
        // 获取项目中的 C# 文件名称
        val csharpFiles = mutableListOf<String>()
        
        // 使用 ProjectRootManager 查找所有 C# 文件
        ProjectRootManager.getInstance(project).fileIndex.iterateContent {\ file ->
            if (file.extension == "cs") {
                csharpFiles.add(file.name)
            }
            true
        }
        
        return csharpFiles.toTypedArray()
    }
    
    override fun getItemsByName(name: String, pattern: String, project: Project, includeNonProjectItems: Boolean): Array<PsiElement> {
        // 查找匹配名称的文件
        val files = mutableListOf<PsiFile>()
        
        FilenameIndex.getFilesByName(project, name, GlobalSearchScope.allScope(project))
            .filter { it.virtualFile.extension == "cs" }
            .forEach { files.add(it) }
        
        return files.toTypedArray()
    }
}
```

### 7.2 符号快速导航

```kotlin
class OmniSharpGotoSymbolProvider : ChooseByNameContributor {
    override fun getNames(project: Project, includeNonProjectItems: Boolean): Array<String> {
        // 获取项目中的符号名称
        val symbols = mutableListOf<String>()
        
        // 实现获取符号名称的逻辑
        // 可以使用 OmniSharp 服务器获取所有符号
        
        return symbols.toTypedArray()
    }
    
    override fun getItemsByName(name: String, pattern: String, project: Project, includeNonProjectItems: Boolean): Array<PsiElement> {
        // 查找匹配名称的符号
        // 实现获取符号的逻辑
        
        return PsiElement.EMPTY_ARRAY
    }
}
```

## 8. 性能优化

### 8.1 导航缓存

```kotlin
class NavigationCache {
    private val definitionCache = ConcurrentHashMap<String, List<Location>>()
    private val referenceCache = ConcurrentHashMap<String, List<Location>>()
    private val hierarchyCache = ConcurrentHashMap<String, TypeHierarchyInfo>()
    
    private val MAX_CACHE_SIZE = 1000
    
    // 定义缓存相关方法
    fun getDefinition(key: String): List<Location>? = definitionCache[key]
    
    fun putDefinition(key: String, locations: List<Location>) {
        manageCacheSize(definitionCache)
        definitionCache[key] = locations
    }
    
    // 引用缓存相关方法
    fun getReferences(key: String): List<Location>? = referenceCache[key]
    
    fun putReferences(key: String, locations: List<Location>) {
        manageCacheSize(referenceCache)
        referenceCache[key] = locations
    }
    
    // 层次结构缓存相关方法
    fun getHierarchy(key: String): TypeHierarchyInfo? = hierarchyCache[key]
    
    fun putHierarchy(key: String, hierarchy: TypeHierarchyInfo) {
        manageCacheSize(hierarchyCache)
        hierarchyCache[key] = hierarchy
    }
    
    private fun <K, V> manageCacheSize(cache: ConcurrentHashMap<K, V>) {
        if (cache.size >= MAX_CACHE_SIZE) {
            // 移除最早添加的项
            val oldestKey = cache.keys.firstOrNull()
            oldestKey?.let { cache.remove(it) }
        }
    }
    
    fun clear() {
        definitionCache.clear()
        referenceCache.clear()
        hierarchyCache.clear()
    }
}
```

### 8.2 异步导航

```kotlin
class AsyncNavigationAction(text: String, val navigationTask: () -> CompletableFuture<Unit>) : AnAction(text) {
    override fun actionPerformed(e: AnActionEvent) {
        val project = e.project ?: return
        
        // 显示进度指示器
        val indicator = ProgressManager.getInstance().progressIndicator
        
        ApplicationManager.getApplication().executeOnPooledThread {
            try {
                // 执行异步导航任务
                navigationTask().get()
            } catch (ex: Exception) {
                ApplicationManager.getApplication().invokeLater {
                    Notifications.Bus.notify(
                        Notification(
                            "OmniSharp",
                            "Navigation Error",
                            "Failed to navigate: ${ex.message}",
                            NotificationType.ERROR
                        ),
                        project
                    )
                }
            }
        }
    }
}
```

## 9. 导航功能配置

### 9.1 快捷键配置

```xml
<!-- 在 plugin.xml 中配置快捷键 -->
<keymap>
  <action id="OmniSharp.GotoDefinition" text="Go to Definition">
    <keyboard-shortcut first-keystroke="control B" keymap="$default" />
  </action>
  <action id="OmniSharp.FindUsages" text="Find Usages">
    <keyboard-shortcut first-keystroke="alt F7" keymap="$default" />
  </action>
  <action id="OmniSharp.TypeHierarchy" text="Type Hierarchy">
    <keyboard-shortcut first-keystroke="control H" keymap="$default" />
  </action>
  <action id="OmniSharp.FileStructure" text="File Structure">
    <keyboard-shortcut first-keystroke="control F12" keymap="$default" />
  </action>
</keymap>
```

### 9.2 配置界面

```kotlin
class OmniSharpNavigationConfigurable : SearchableConfigurable {
    override fun getId(): String = "omniSharp.navigation"
    
    override fun getDisplayName(): String = "Navigation"
    
    override fun createComponent(): JComponent {
        val panel = JPanel(BorderLayout())
        
        // 启用快速导航
        val enableQuickNavigation = JCheckBox("Enable Quick Navigation")
        enableQuickNavigation.isSelected = true
        
        // 启用预览
        val enablePreview = JCheckBox("Enable Navigation Preview")
        enablePreview.isSelected = true
        
        // 布局组件
        val contentPanel = JPanel(GridLayout(0, 1, 0, 10))
        contentPanel.add(enableQuickNavigation)
        contentPanel.add(enablePreview)
        
        panel.add(contentPanel, BorderLayout.NORTH)
        return panel
    }
    
    // 其他必要的方法实现
}
```

## 10. 常见问题与解决方案

### 10.1 导航功能不工作

**问题症状**：点击 "Go to Definition" 没有任何反应。

**可能原因**：
- OmniSharp 服务器未启动或已崩溃
- 符号未正确索引
- 项目配置不正确

**解决方案**：
1. 检查 OmniSharp 服务器状态
2. 重新启动 OmniSharp 服务器
3. 重建项目索引
4. 检查项目文件是否正确

### 10.2 导航结果不准确

**问题症状**：导航到错误的位置或找不到定义。

**可能原因**：
- 缓存过期
- 代码有语法错误
- 引用路径配置不正确

**解决方案**：
1. 清除缓存（File | Invalidate Caches / Restart）
2. 修复代码中的语法错误
3. 检查项目引用路径
4. 确保使用最新版本的 OmniSharp 服务器

### 10.3 导航速度慢

**问题症状**：导航操作响应时间长。

**可能原因**：
- 大型项目
- 服务器性能问题
- 缓存配置不当

**解决方案**：
1. 增加缓存大小
2. 启用持久化缓存
3. 优化服务器性能
4. 排除不需要索引的文件和目录

## 11. 下一步

完成代码导航功能集成后，可以继续学习以下阶段的内容：

1. **阶段四：代码诊断与错误检查** - 学习如何实现实时错误检查和警告
2. **阶段五：代码格式化与风格管理** - 学习如何实现代码格式化功能
3. **阶段六：高级功能与性能优化** - 学习如何实现高级功能和性能优化

---

本文档是 OmniSharp-for-Intellij 编辑器功能集成指南的第三阶段，详细介绍了代码导航功能的实现原理、核心接口、各种导航功能的具体实现方法和性能优化策略。通过本阶段的学习，开发者应该能够理解和实现高质量的代码导航功能。